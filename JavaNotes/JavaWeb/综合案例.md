# JavaWeb综合案例

完成品牌数据的增删改查，批量删除，分页查询，条件查询

前端Vue Element + 后端MyBatis servlet

## 查询所有

Mapper-brandMapper.java

1.      @Select("select \* from tb_brand")
2.      @ResultMap（"brandResultMap"）
3.      List<Brand> selectAll();

由于Brand实体类中的名称与数据库表中字段不匹配，需要使用resultMap进行映射

resourses-com-itheima-mapper-brandMapper.xml

1.  <mapper namespace="com.itheima.mapper.BrandMapper">
2.      <resultMap id="brandResultMap" type="brand">
3.          <result property="brandName" column="brand_name" />
4.          <result property="companyName" column="company_name" />
5.      </resultMap>
6.  </mapper>

service-BrandMapper.java

创建一个接口，在接口中写方法

1.  List<Brand> selectAll();

service-impl-brandServiceImpl

1.  public class brandServiceImpl implements BrandService {
2.      _//1.创建sqlSessionFactory_
3.      SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory();
4.      @Override
5.      public List<Brand> selectAll() {

6.          _//2.获取SqlSession对象_
7.          SqlSession sqlSession = sqlSessionFactory.openSession();    

8.         _//3.获取BrandMapper_
9.         BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

10.         List<Brand> brands = mapper.selectAll();

11. _//5.释放资源_
12. sqlSession.close();
13.         return brands;

14.     }
15. }

通过接口-实现类，通过一些框架设计web层和service层可以解耦合

web-SelectAllServlet

1.  @WebServlet("/selectAllServlet")
2.  public class SelectAllServlet {

3.      private BrandService brandService = new brandServiceImpl();

4.      protected void doGet(HttpServletRequest request, HttpServletResponse response)
5.              throws ServletException, IOException {

6.         _//1. 调用service查询_
7.         List<Brand> brands = brandService.selectAll();

8.         _//2.转为json_
9.         String jsonString = JSON.toJSONString(brands);   

10.         _//3.写数据_
11.         response.setContentType("text/json;charset=utf-8");
12.         response.getWriter().write(jsonString);
13.     }

14.     protected void doPost(HttpServletRequest request, HttpServletResponse response)
15.             throws ServletException, IOException {
16. this.doGet(request, response);
17.     }
18. }

关于测试：Tomcat启程序，访问selectAllservlet，看到一系列的json数据则后台接收数据无误

\--后台代码#end

brand.html

1.      new Vue({
2.          el: "#app",

3.          mounted() {
4.              _//当页面加载完成后，发送异步请求_

5.              var \_this = this;

6.              axios({
7.                 method: "get",
8.                 url: "http://localhost:8080/brand-case/selectAllServlet"
9.             }).then(function(resp) {

10.                 \_this.tableData = resp.data;
11.             })

12.         },
13. }

当页面加载完成时候，发送异步请求来获取数据

通过then回调，获取响应，绑定function函数，resp.data就是列表数据，传到表格数据的模型上，this不能直接使用，声明提高级别

\--前端代码#end

## 新增品牌

Mapper-BrandMapper.java

1.      @Insert("insert into tb_brand values (null,#{brandName},#{companyName},#{ordered},#{description},#{status})")
2.      void add(Brand brand);

service-BrandMapper.java

1.  void add(Brand brand);

service-impl-BrandServiceImpl

1.      @Override
2.      public void add(Brand brand) {

3.          _//2.获取SqlSession对象_
4.          SqlSession sqlSession = sqlSessionFactory.openSession();

5.          _//3.获取BrandMapper_
6.          BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

7.         mapper.add(brand);

8.         _//4.提交事务_
9.         sqlSession.commit();

10.         _//5.释放资源_
11.         sqlSession.close();

12.     }

web-AddServlet

1.  @WebServlet("/addServlet")
2.  public class AddServlet {

3.      private BrandService brandService = new brandServiceImpl();

4.      protected void doGet(HttpServletRequest request, HttpServletResponse response)
5.              throws ServletException, IOException {

6.        _//1.接收品牌数据_
7.         BufferedReader br = request.getReader();
8.         String params = br.readLine();_//json字符串_

9.         _//2.转为brand对象_
10.         Brand brand = JSON.parseObject(params, Brand.class);

11.         _//3.调用service添加_
12.         brandService.add(brand);

13.         _//4.响应结果_
14.         response.getWriter().write("success");
15.     }

16.     protected void doPost(HttpServletRequest request, HttpServletResponse response)
17.             throws ServletException, IOException {
18. this.doGet(request, response);
19.     }
20. }

数据以json格式提交，使用request.getReader来获取消息体数据

\--后端代码#end

1.              <el-form-item>
2.                  <el-button type="primary" @click="addBrand">提交</el-button>
3.                  <el-button @click="dialogVisible = false">取消</el-button>
4.              </el-form-item>

静态页面表单的案件绑定，将按钮绑定单击事件addBrand

brand.html

1.              addBrand(){
2.                  _//console.log(this.brand);_

3.                  var \_this = this;

4.                  _//发送ajax异步请求_
5.                  axios({
6.                     method: "post",
7.                     url: "http://localhost:8080/brand-case/addServlet",
8.                    data: \_this.brand

9.                 }).then(function (resp){

10.                     _//添加成功_
11.                     if(resp.data() == "success"){

12.                         _//关闭窗口_
13.                         \_this.dialogVisible = false;

14.                         _//重新查询数据_                        
15.                         \_this.selectAll();

16.                         \_this.$message({
17.                             message: '添加成功',
18.                             type: 'success'
19.                         });

20.                     }
21.                 })
22.             },
23.                 })
24.             },

为了方便调用selectAll来展示数据，直接将selectAll封装成一个方法

1.   mounted() {this.selectAll()；},

可以加入’添加成功’提示框功能

前端代码#end

#修改品牌

#删除品牌

## Servlet代码优化

- Web层的Servlet个数太多，不利于管理和编写
- 将Servlet进行归类，对于同一个实体的操作方法，写到一个Servlet中，比如BrandServlet，UserServlet
- 不能继承HttpServlet，自定义Servlet，使用请求路径进行方法分发，替换HttpServlet的根据请求方式进行方法分发

反射调用：

1.  _/\*\*_
2.   \* 替换HttpServlet，根据请求的最后一段路径来进行方法分发
3.   \*/
4.  public class BaseServlet extends HttpServlet {
5.      @Override
6.      protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
7.          _//1.获取请求路径_
8.         String uri = req.getRequestURI();_// /brand-case/brand/selectAll_

9.         _//2.获取最后一段路径，方法名_
10.         int index = uri.lastIndexOf('/');_//获取最后一个/的位置_
11.         String methodName = uri.substring(index + 1);

12.         _//3.获取BrandServlet/UserServlet 字节码对象 class_
13.         _//谁调用我（this所在的方法），我（this）调用谁，这里的this指BrandServlet(baseServlet的子类们)，而不是Httpservlet_
14.         Class<? extends BaseServlet> cls = this.getClass();

15.         _//获取方法Method对象_
16.         try {
17.             Method method = cls.getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class);
18.             _//执行方法_
19.             method.invoke(this,req,resp);

20.         }catch (NoSuchMethodException e){
21.             e.printStackTrace();
22.         } catch (InvocationTargetException e) {
23.             throw new RuntimeException(e);
24.         } catch (IllegalAccessException e) {
25.             throw new RuntimeException(e);
26.         }
27.     }
28. }

一个通用的 HttpServlet 替代类，用于根据 URL 路径动态调用子类中的方法。继承自 HttpServlet。然后重写父类 service() 方法，处理所有 HTTP 请求（GET、POST 等）。参数：req: 封装了客户端的请求信息。resp: 用于向客户端发送响应。再获取当前请求的 URI。当访问 /brand-case/brand/selectAll 时，得到字符串 /brand-case/brand/selectAll。找到最后一个斜杠 / 的位置，并提取其后的内容作为方法名。uri.substring(index + 1) 得到 "selectAll"。获取当前对象的实际运行时类的 Class 对象。如果当前是 BrandServlet 实例，则返回 BrandServlet.class。使用反射获取名为 methodName 的方法对象，要求该方法接受两个参数：HttpServletRequest 和 HttpServletResponse。使用反射调用该方法，并传入当前请求和响应对象。

对此前写的代码进行优化

1.  @WebServlet("/brand/\*")
2.  public class BrandServlet {

3.      private BrandService brandService = new brandServiceImpl();

4.      public void selectAll(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}

5.      public void add(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{}
6.  }

## 批量删除

Mapper-BrandMapper.java

1.      void deleteByIds(@Param("ids")int\[\] ids);

@Param("ids") 表示将方法参数 int\[\] ids 命名为 "ids"，以便在对应的 SQL 语句中引用。

当这个方法被调用时，传入的 ids 数组可以通过名称 "ids" 在 MyBatis 的 XML 映射文件或注解中的 SQL 语句里使用。

Resources-com-itheima-brandMapper.xml

1.      <delete id="delectByIds" >
2.          delete from tb_brand where in
3.          <foreach item="id" collection="ids" separator="," open="(" close=")">
4.              _#{id}_
5.          </foreach>
6.      </delete>

Sql语句复杂使用配置文件编写sql语句

service-BrandService.java

1.      void deleteByIds(int\[\] ids);

在接口中创建方法，接下来在实现类中实现该方法

service-BrandServiceImpl.java

1.      @Override
2.      public void deleteByIds(int\[\] ids) {

3.          _//2.获取SqlSession对象_
4.          SqlSession sqlSession = sqlSessionFactory.openSession();

5.          _//3.获取BrandMapper_
6.          BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

7.         mapper.deleteByIds(ids);

8.         _//4.提交事务_
9.         sqlSession.commit();

10.         _//5.释放资源_
11.         sqlSession.close();

12.     }

在实现类中调用方法

web-BrandServlet

1.      public void deleteByIds(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{

2.          _//1.接收id数组\[1,2,3\]_
3.          BufferedReader br = request.getReader();
4.          String params = br.readLine();_//json字符串_

5.          _//2.转为int数组_
6.          int\[\] ids = JSON.parseObject(params, int\[\].class);

7.         _//3.调用service添加_
8.         brandService.deleteByIds(ids);

9.         _//4.响应结果_
10.         response.getWriter().write("success");
11.     }

\--后端代码#end

brand.html

1.  <el-button type="danger" plain @click="deleteByIds">批量删除</el-button>

静态页面，按键绑定deleteByIds事件，实现批量删除

1.              deleteByIds(){
2.                  _//1.创建id数组\[1,2,3\]_
3.                  for (let i = 0; i < this.multipleSelection.length; i++) {
4.                      let selectionElements = this.multipleSelection\[i\];
5.                      this.selectedIds\[i\] = selectionElements.id;
6.                  }

7.                  _//2.发送ajax异步请求_
8.                  axiosaxios({
9.                     method: "post",
10.                     url: "http://localhost:8080/brand-case/deleteByIds",
11.                     data: \_this.deleteByIds

12.                 }).then(function (resp){

13.                     _//删除成功_
14.                     if(resp.data() == "success"){

15.                         _//重新查询数据_
16.                         \_this.selectAll();

17.                         \_this.$message({
18.                             message: '添加成功',
19.                             type: 'success'
20.                         });
21.                     }
22.                 })
23.             }

创建方法deleteByIds，从multipleSelection中获取数据，并通过遍历，将数据存储到自建的selectedIds模型中

在data中新建一个selectedIds模型 id被选中，数组值发生变化，提交数据时提交数组到后台

1.                  //被选中的id数组
2.                  selectedIds:\[\],

优化：在删除时跳出确认框，确认是否删除

1.              _//批量删除_
2.              deleteByIds(){
3.                  _// 弹出确认提示框_

4.                  this.$confirm('此操作将删除该数据, 是否继续?', '提示', {
5.                      confirmButtonText: '确定',
6.                      cancelButtonText: '取消',
7.                      type: 'warning'
8.                  }).then(() => {
9.                     _//用户点击确认按钮_

10.                     _//1. 创建id数组 \[1,2,3\], 从 this.multipleSelection 获取即可_
11.                     for (let i = 0; i < this.multipleSelection.length; i++) {
12.                         let selectionElement = this.multipleSelection\[i\];
13.                         this.selectedIds\[i\] = selectionElement.id;

14.                     }

15.                     _//2. 发送AJAX请求_
16.                     var \_this = this;

17.                     _// 发送ajax请求，添加数据_
18.                     axios({
19.                         method:"post",
20.                         url:"http://localhost:8080/brand-case/brand/deleteByIds",
21.                         data:\_this.selectedIds
22.                     }).then(function (resp) {
23.                         if(resp.data == "success"){
24.                             _//删除成功_

25.                             _// 重新查询数据_
26.                             \_this.selectAll();
27.                             _// 弹出消息提示_
28.                             \_this.$message({
29.                                 message: '恭喜你，删除成功',
30.                                 type: 'success'
31.                             });

32.                         }
33.                     })
34.                 }).catch(() => {
35.                     _//用户点击取消按钮_

36.                     this.$message({
37.                         type: 'info',
38.                         message: '已取消删除'
39.                     });
40.                 });

41.             }

用then catch包裹两种条件

\--前端代码#end

## 分页查询

- 分页查询LIMIT，参数1：开始索引，参数2：查询的条目数

SELECT \* FROM tb_brand LIMIT 0,5

- 页面（前端）传递的参数- 当前页码currentPage 与 每页查询的条目数pageSize
- 后台返回的数据- 当前页数据 List 与 总记录数 totalCount
- 开始索引 = （当前页数-1）\* 每页显示条数
- 查询条目数 = 查询的条目数 = 每页显示条数

Pojo-PageBean

1.  _//分页查询的JavaBean_
2.  public class PageBean<T> {
3.      _// 总记录数_
4.      private int totalCount;
5.      _// 当前页数据_
6.      private List<T> rows;

7.      public int getTotalCount() {
8.         return totalCount;
9.     }

10.     public void setTotalCount(int totalCount) {
11.         this.totalCount = totalCount;
12.     }

13.     public List<T> getRows() {
14.         return rows;
15.     }

16.     public void setRows(List<T> rows) {
17.         this.rows = rows;
18.     }
19. }

实体类中定义bean，泛型声明一个T，可以让代码通用，在pagebean中存放总记录数与当前页数据，并设置getter/setter方法

Mapper-BrandMapper.java

1.  _/\*\*_
2.       \* 分页查询
3.       \* @param begin
4.       \* @param size
5.       \* @return
6.       \*/
7.      @Select("select \* from tb_brand limit #{begin} , #{size}")
8.      @ResultMap("brandResultMap")
9.      List<Brand> selectByPage(@Param("begin") int begin,@Param("size") int size);

10.     _/\*\*_
11.      \* 查询总记录数
12.      \* @return
13.      \*/
14.     @Select("select count(\*) from tb_brand ")
15. @ResultMap("brandResultMap")
16.     int selectTotalCount();

BrandService.java

1.      _/\*\*_
2.       \* 分页查询
3.       \* @param currentPage  当前页码
4.       \* @param pageSize   每页展示条数
5.       \* @return
6.       \*/
7.      PageBean<Brand>  selectByPage(int currentPage,int pageSize);

返回一个Pagebean对象，由前端传入currentPage和pageSize

Service-impl-brandServiceImpl.java

1.  @Override
2.      public PageBean<Brand> selectByPage(int currentPage, int pageSize) {
3.          _//2. 获取SqlSession对象_
4.          SqlSession sqlSession = factory.openSession();
5.          _//3. 获取BrandMapper_
6.          BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

7.          _//4. 计算开始索引_
8.         int begin = (currentPage - 1) \* pageSize;
9.         _// 计算查询条目数_
10.         int size = pageSize;

11.         _//5. 查询当前页数据_
12.         List<Brand> rows = mapper.selectByPage(begin, size);

13.         _//6. 查询总记录数_
14.         int totalCount = mapper.selectTotalCount();

15.         _//7. 封装PageBean对象_
16.         PageBean<Brand> pageBean = new PageBean<>();
17.         pageBean.setRows(rows);
18.         pageBean.setTotalCount(totalCount);

19.         _//8. 释放资源_
20.         sqlSession.close();

21.         return pageBean;
22.     }

BrandServlet.java

1.  public void selectByPage(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
2.          _//1. 接收 当前页码 和 每页展示数    url?currentPage=1&pageSize=5_
3.          String \_currentPage = request.getParameter("currentPage");
4.          String \_pageSize = request.getParameter("pageSize");

5.          int currentPage = Integer.parseInt(\_currentPage);
6.          int pageSize = Integer.parseInt(\_pageSize);

7.          _//2. 调用service查询_
8.         PageBean<Brand> pageBean = brandService.selectByPage(currentPage, pageSize);

9.         _//2. 转为JSON_
10.         String jsonString = JSON.toJSONString(pageBean);
11.         _//3. 写数据_
12.         response.setContentType("text/json;charset=utf-8");
13.         response.getWriter().write(jsonString);
14.     }

请求中接收的类型是String类型，而查询中需要的为int类型，所以需要强制转换

后端代码#end

brand.html

1.              selectAll(){

2.                  var \_this = this;

3.                  axios( {
4.                      method: "post",
5.                      url: "http://localhost:8080/brand-case/brand/selectByPage?currentPage=" + \_this.currentPage + "&pageSize="+ \_this.pageSize,

6.                 }).then(function(resp){
7.                     \_this.tableData = resp.data.rows;
8.                     \_this.totalCount = resp.data.totalCount;
9.                     console.log(resp.data);
10.                 })

11.             },

因为修改分页查询，相当于修改了selectAll的显示方式，此前是加载完成之后就执行selectAll，这里url直接使用拼字符串的方式，将tableData模型数据设置成rows即当前页的数据，totalCount为页的数量，也建立到一个模型中。通过响应到的数据来为这两个模型设置值

在data中设置模型：pageSize，totalCount和currentPage其中5，100为默认值

1.                  _//每页显示的条数_
2.                  pageSize:5,
3.                  _//总记录数_
4.                  totalCount:100,
5.                  _// 当前页码_
6.                  currentPage: 1,

分页工具条

1.      <!--分页工具条-->
2.      <el-pagination
3.              @size-change="handleSizeChange"
4.              @current-change="handleCurrentChange"
5.              :current-page="currentPage"
6.              :page-sizes="\[5, 10, 15, 20\]"
7.              :page-size="5"
8.              layout="total, sizes, prev, pager, next, jumper"
9.              :total="totalCount">
10.     </el-pagination>

Total处展示总记录数，建立到totalCount模型中，@size-change，@current-change是动态分页的方法

动态分页

1.    _//分页_
2.              handleSizeChange(val) {
3.                  _// console.log(\`每页 ${val} 条\`);_
4.                  _//重新设置每页显示的条数_
5.                  this.pageSize = val;
6.                  this.selectAll();
7.              },
8.              handleCurrentChange(val) {
9.                  _//console.log(\`当前页: ${val}\`);_

10.                 _//重新设置当前页码_
11.                 this.currentPage = val;
12.                 this.selectAll();
13.             },

Val用来接收分页工具栏停留的位置，以及需要显示的数量

前端代码#end

## 条件查询

需要完成条件查询，并且按照分页的形式展示

BrandMapper.java

1.      _/\*\*_
2.       \* 分页条件查询
3.       \* @param begin
4.       \* @param size
5.       \* @return
6.       \*/
7.      List<Brand> selectByPageAndCondition(@Param("begin") int begin, @Param("size") int size, @Param("brand") Brand brand);

8.      _/\*\*_
9.      \* 根据条件查询总记录数
10.      \* @return
11.      \*/

12.     Integer selectTotalCountByCondition(Brand brand);

使用Integer即使查询结果为空，MyBatis 也能安全地返回 null，而不会引发类型不匹配异常

BrandMapper.xml

1.      <select id="selectByPageAndCondition" resultMap="brandResultMap">
2.          select \*
3.          from tb_brand
4.          <where>
5.          <if test=" brandName != null and  brandName ！=''">
6.              and brand_name like _#{ brandName}_
7.          </if>

8.          <if test=" companyName != null and  companyName ！=''">
9.             and company_name like _#{ companyName}_
10.         </if>

11.         <if test=" status != null ">
12.             and status = _#{ status}_
13.         </if>

14.         </where>

15.         limit _#{begin},#{size}_
16.     </select>

17.     <select id="selectTotalCountByCondition" resultMap="brandResultMap">
18.         select count(\*)
19.         from tb_brand
20.         <where>
21.             <if test=" brandName != null and  brandName ！=''">
22.                 and brand_name like _#{ brandName}_
23.             </if>

24.             <if test=" companyName != null and  companyName ！=''">
25.                 and company_name like _#{ companyName}_
26.             </if>

27.             <if test=" status != null ">
28.                 and status = _#{ status}_
29.             </if>

30.         </where>

31.     </select>

由于需要写动态SQL，所以在XML文件中编辑，第二个select语句中，由于没有采用@brand注解，可以直接使用brand实体类中的属性，所以可以省略brand. ，同时希望模糊匹配没使用like，而不是=

BrandService.java

1.  PageBean<Brand> selectByPageAndCondition(int currentPage, int pageSize, Brand brand);

分页条件查询，返回一个pageBean

BrandServiceImpl.java

1.      @Override
2.      public PageBean<Brand> selectByPageAndCondition(int currentPage, int pageSize, Brand brand) {

3.          _//2.获取SqlSession对象_
4.          SqlSession sqlSession = factory.openSession();

5.          _//3.获取BrandMapper_
6.          BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);

7.         _//计算开始索引_
8.         int begin = (currentPage-1) \* pageSize;
9.         _//计算查询条目数_
10.         int size = pageSize;

11.         _//处理brand条件，模糊表达式_
12.         String brandName = brand.getBrandName();
13.         if(brandName != null && brandName.length() > 0){
14.             brand.setBrandName("%" + brandName + "%");
15.         }

16.         String companyName = brand.getCompanyName();
17.         if(companyName != null && companyName.length() > 0){
18.             brand.setCompanyName("%" + companyName + "%");
19.         }

20.         _//4.查询当前页数据_
21.         List<Brand> rows = mapper.selectByPageAndCondition(begin, size,brand);

22.         _//5.查询总记录数_
23.         int totalCount = mapper.selectTotalCountByCondition(brand);

24.         PageBean<Brand> pageBean = new PageBean<>();
25.         pageBean.setRows(rows);
26.         pageBean.setTotalCount(totalCount);

27.         sqlSession.close();

28.         return pageBean;
29.     }

新增处理brand对象，使模糊表达式，对用户的输入封装成模糊表达式的形式

BrandServlet.java

1.      public void selectByPageAndCondition(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
2.          _//1. 接收两个参数 currentPage pageSize_
3.          String \_currentPage = request.getParameter("currentPage");
4.          String \_pageSize = request.getParameter("pageSize");

5.          _//获取查询条件对象_
6.          BufferedReader br = request.getReader();
7.          String params = br.readLine();_//json字符串_

8.         Brand brand = JSON.parseObject(params, Brand.class);

9.         int currentPage = Integer.parseInt(\_currentPage);
10.         int pageSize = Integer.parseInt(\_pageSize);

11.         PageBean<Brand> pageBean = brandService.selectByPageAndCondition(currentPage, pageSize,brand);

12.         _//转为json_
13.         String json = JSON.toJSONString(pageBean);
14.         response.setContentType("text/json;charset=utf-8");
15.         response.getWriter().write(json);
16.     }

Brand的数据通过前端传递，将method改为post方式，使用data来传递，接收请求体的参数，currentPage和pageSize使用url来传递

后端代码#end

Brand.html

1.              _//查询所有_
2.              selectAll(){

3.                  var \_this = this;

4.                  axios( {
5.                      method: "post",
6.                      url: "http://localhost:8080/brand-case/brand/selectByPageAndCondition?currentPage=" + \_this.currentPage + "&pageSize="+ \_this.pageSize,
7.                      data:this.brand

8.                 }).then(function(resp){
9.                     \_this.tableData = resp.data.rows;
10.                     \_this.totalCount = resp.data.totalCount;
11.                     console.log(resp.data);
12.                 })

13.             },
14.             onSubmit() {
15.                 console.log(this.brand);
16.                 this.selectAll()
17.             },

将请求改为post形式，并使用data将brand传入selectAll中，查询按键绑定onSubmit事件，点击时调用selectAll方法

前端代码优化

Var \_this = this 使用麻烦

使用=>箭头函数，不用再使用_this

1.  axios({
2.                      method:"post",
3.                      url:"http://localhost:8080/brand-case/brand/selectByPageAndCondition?currentPage="+this.currentPage+"&pageSize="+this.pageSize,
4.                      data:this.brand
5.                  }).then(resp =>{
6.                      _//设置表格数据_
7.                      this.tableData = resp.data.rows; _// {rows:\[\],totalCount:100}_
8.                      _//设置总记录数_
9.                      this.totalCount = resp.data.totalCount;
10.                 })

\--前端代码#end
