
# 会话跟踪技术

## 1. 概念与概述

- **会话**：用户打开浏览器，访问 Web 服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中包含多次请求和响应。
    
- **会话跟踪**：是一种维护浏览器状态的方法。服务器需要识别多次请求是否来自同一浏览器，以便在同一次会话的多次请求间共享数据。
    
- **背景**：HTTP 协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此需要会话跟踪技术来实现会话内数据共享。
    
- **实现方式**：
    
    - 客户端会话跟踪技术：**Cookie**
        
    - 服务端会话跟踪技术：**Session**
        

---

## 2. Cookie (客户端会话技术)

Cookie 将数据保存到客户端，以后每次请求都携带 Cookie 数据进行访问。

### 2.1 Cookie 快速入门

#### 1. 发送 Cookie (服务端 -> 客户端)

1. 创建 Cookie 对象，设置数据。
    
2. 使用 `response` 对象发送 Cookie 到客户端。

```Java
// 1. 创建Cookie对象
Cookie cookie = new Cookie("key", "value");

// 2. 发送Cookie到客户端
response.addCookie(cookie);
```

#### 2. 获取 Cookie (客户端 -> 服务端)

1. 使用 `request` 对象获取客户端携带的所有 Cookie。
    
2. 遍历数组，获取每一个 Cookie 对象。
    
3. 使用 Cookie 对象方法获取数据。

```Java
// 1. 获取客户端携带的所有Cookie
Cookie[] cookies = request.getCookies();

// 2. 遍历
if (cookies != null) {
    for (Cookie c : cookies) {
        String name = c.getName();
        String value = c.getValue();
        System.out.println(name + ":" + value);
    }
}
```

### 2.2 Cookie 原理

- Cookie 的实现是基于 HTTP 协议的。
    
- **发送 Cookie**：依赖响应头 `set-cookie`。
    
- **获取 Cookie**：依赖请求头 `cookie`。
    

### 2.3 Cookie 使用细节

#### 1. Cookie 存活时间

默认情况下，Cookie 存储在浏览器内存中，当浏览器关闭，内存释放，则 Cookie 被销毁。可以使用 `setMaxAge(int seconds)` 设置存活时间：

- **正数**：将 Cookie 写入浏览器所在电脑的硬盘，**持久化存储**，到时间自动删除。
    
- **负数**：默认值，Cookie 在当前浏览器内存中，当浏览器关闭，则 Cookie 被销毁。
    
- **零**：删除对应 Cookie。
    

#### 2. Cookie 存储中文

默认情况下，Cookie 不能直接存储中文。如需要存储，则需要进行 **URL 编码/解码**：

**发送端 (编码)：**

```Java
String value = "张三";
// URL编码
value = URLEncoder.encode(value, "UTF-8");
Cookie cookie = new Cookie("username", value);
```

**接收端 (解码)：**

```Java
// URL解码
value = URLDecoder.decode(value, "UTF-8");
```

---

## 3. Session (服务端会话技术)

Session 将数据保存到服务端。JavaEE 提供 `HttpSession` 接口，来实现一次会话的多次请求间数据共享功能。

### 3.1 Session 基本使用

#### 1. 获取 Session 对象

```Java
HttpSession session = request.getSession();
```

#### 2. Session 对象功能

- `void setAttribute(String name, Object o)`：存储数据到 session 域中。
    
- `Object getAttribute(String name)`：根据 key，获取值。
    
- `void removeAttribute(String name)`：根据 key，删除该键值对。
    

### 3.2 Session 原理

- Session 是基于 Cookie 实现的。
    
- 一次会话的多个请求间，不论获取多少次 Session 对象，获取的 Session 对象始终是同一个。
    
- **核心机制**：通过 Cookie 中的 **JSESSIONID** 来实现 Session 的查找与绑定。
    

### 3.3 Session 使用细节

#### 1. Session 钝化与活化 (自动实现)

- **钝化**：在服务器正常关闭后，Tomcat 会自动将 Session 数据写入硬盘的文件中。
    
- **活化**：再次启动服务器后，从文件中加载数据到 Session 中。
    
    - _注意_：服务器重启后，Session 数据存在，但底层的 Session 对象实例可能发生变化。
        

#### 2. Session 销毁

- **默认销毁**：无操作 30 分钟后自动销毁。
    
    - 配置方式 (`web.xml`)：
        
        
        ```XML
        <session-config>
             <session-timeout>100</session-timeout>
        </session-config>
        ```
        
- **主动销毁**：调用 Session 对象的 `invalidate()` 方法。
    

---

## 4. 小结：Cookie 与 Session 的区别

|**特性**|**Cookie**|**Session**|
|---|---|---|
|**存储位置**|客户端 (浏览器)|服务端|
|**安全性**|不安全 (易被篡改/截获)|安全|
|**数据大小**|最大 3KB|无大小限制|
|**存储时间**|可长期存储 (硬盘)|默认 30 分钟 (内存/钝化)|
|**服务器性能**|不占服务器资源|占用服务器资源 (内存)|

**应用场景分析：**

- **购物车数据**：Cookie
    
- **偏好设置**：Cookie
    
- **记住我功能**：Cookie (存在被盗用风险，需配合加密)
    
- **用户数据 (登录信息)**：Session
    
- **验证码**：Session (防止暴力注入，保证安全性)
    

---

## 5. 案例实战：登录注册

### 5.1 需求说明

1. **用户登录**：完成登录功能，若勾选“记住用户”，下次访问自动填充用户名和密码。
    
2. **用户注册**：完成注册功能，并实现验证码校验功能。
    

### 5.2 用户登录功能

#### 1. DAO 层 (UserMapper.java)

```Java
/**
 * 根据用户名和密码查询用户对象
 */
@Select("select * from tb_user where username = #{username} and password = #{password}")
User select(@Param("username") String username, @Param("password") String password);
```

#### 2. Service 层 (UserService.java)

```Java

public class UserService {
    SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory();

    public User login(String username, String password){
        // 1. 获取SqlSession
        SqlSession sqlSession = factory.openSession();
        // 2. 获取UserMapper
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        // 3. 调用方法
        User user = mapper.select(username, password);
        // 4. 释放资源
        sqlSession.close();
        return user;
    }
}
```

#### 3. Web 层 (LoginServlet.java)

**核心逻辑**：

- 调用 Service 查询用户。
    
- **登录成功**：将 user 对象存入 `Session`，重定向到主页。
    
- **登录失败**：将错误信息存入 `request`，转发回登录页。
    


```Java

@WebServlet("/loginServlet")
public class LoginServlet extends HttpServlet {
    private UserService service = new UserService();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 1. 获取用户名和密码
        String username = request.getParameter("username");
        String password = request.getParameter("password");
        
        // 2. 调用service查询
        User user = service.login(username, password);

        if (user != null){
            // --- 登录成功 ---
            // 将登录成功后的user对象存储到session中
            HttpSession session = request.getSession();
            session.setAttribute("user", user);

            // 重定向
            String contextPath = request.getContextPath();
            response.sendRedirect(contextPath + "/selectAllServlet");
        } else {
            // --- 登录失败 ---
            // 错误信息存入request
            request.setAttribute("login_msg", "用户名或密码错误");
            // 转发回login.jsp
            request.getRequestDispatcher("/login.jsp").forward(request, response);
        }
    }
    
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doGet(request, response);
    }
}
```

#### 4. JSP 页面展示 (login.jsp)



```Java
<div id="errorMsg">${login_msg}</div>
```

### 5.3 “记住用户”功能 (Cookie)

#### 1. 写 Cookie (LoginServlet 修改)

**逻辑**：登录成功且勾选了复选框 -> 创建存储用户名密码的 Cookie -> 设置最大存活时间 -> 发送给客户端。


```Java
// 在登录成功的逻辑块中添加：
String remember = request.getParameter("remember");

if("1".equals(remember)){
    // 勾选了记住我
    // 1. 创建Cookie
    Cookie c_username = new Cookie("username", username);
    Cookie c_password = new Cookie("password", password); // 注意：实际生产中密码不应明文存储

    // 2. 设置Cookie的存活时间 (例如7天)
    c_username.setMaxAge(60*60*24*7);
    c_password.setMaxAge(60*60*24*7);

    // 3. 发送
    response.addCookie(c_username);
    response.addCookie(c_password);
}
```

#### 2. 页面回显 Cookie (login.jsp)

使用 EL 表达式获取 Cookie 中的值并填充到 input 框中。

```HTML
<p>Username: <input id="username" name="username" value="${cookie.username.value}" type="text"></p>
<p>Password: <input id="password" name="password" type="password" value="${cookie.password.value}"></p>
<p>Remember: <input id="remember" name="remember" value="1" type="checkbox"></p>
```

### 5.4 用户注册功能

#### 1. DAO 层

```Java
// 查询用户名是否存在
@Select("select * from tb_user where username = #{username}")
User selectByUsername(String username);

// 添加用户
@Insert("insert into tb_user values(null, #{username}, #{password})")
void add(User user);
```

#### 2. Service 层 (逻辑：先查后存)

```Java
public boolean register(User user){
    SqlSession sqlSession = factory.openSession();
    UserMapper mapper = sqlSession.getMapper(UserMapper.class);

    // 判断用户名是否存在
    User u = mapper.selectByUsername(user.getUsername());

    if (u == null){
        // 用户名不存在，注册
        mapper.add(user);
        sqlSession.commit();
    }
    sqlSession.close();
    return u == null; // 返回true表示注册成功
}
```

#### 3. Web 层 (RegisterServlet.java)

```Java
@WebServlet("/registerServlet")
public class RegisterServlet extends HttpServlet {
    private UserService service = new UserService();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // ... 获取参数封装User对象 ...
        
        boolean flag = service.register(user);
        if (flag){
            // 注册成功，跳转登录页面
            request.setAttribute("register_msg", "注册成功请登录");
            request.getRequestDispatcher("/login.jsp").forward(request, response);
        } else {
            // 注册失败，跳转注册页面
            request.setAttribute("register_msg", "用户名已存在");
            request.getRequestDispatcher("/register.jsp").forward(request, response);
        }
    }
}
```

### 5.5 验证码功能

#### 1. 生成验证码 (CheckCodeServlet)

使用工具类生成图片，并将验证码字符存入 **Session** 用于后续校验。

```Java
@WebServlet("/checkCodeServlet")
public class CheckCodeServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletOutputStream os = response.getOutputStream();
        // 生成验证码图片并输出到流，同时返回验证码字符
        String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4);
        
        // 核心：将验证码存入 Session
        HttpSession session = request.getSession();
        session.setAttribute("checkCodeGen", checkCode);
    }
}
```

#### 2. 页面展示与切换 (register.jsp)

点击链接或图片时，通过修改 `src` 属性并添加时间戳参数来强制刷新图片。

```HTML
<img id="checkCodeImg" src="/brand-demo/checkCodeServlet">
<a href="#" id="changeImg">看不清？</a>

<script>
    document.getElementById("changeImg").onclick = function (){
        // 加时间戳防止浏览器缓存
        document.getElementById("checkCodeImg").src = "/brand-demo/checkCodeServlet?time=" + new Date().getTime();
    }
</script>
```

#### 3. 校验验证码 (RegisterServlet 修改)

在注册逻辑执行前，先从 Session 获取生成的验证码与用户输入的进行比对。

```Java
// 1. 获取用户输入的验证码
String checkCode = request.getParameter("checkCode");

// 2. 获取程序生成的验证码（从Session中）
HttpSession session = request.getSession();
String checkCodeGen = (String) session.getAttribute("checkCodeGen");

// 3. 比对 (忽略大小写)
if(!checkCodeGen.equalsIgnoreCase(checkCode)){
    // 验证码错误，阻止注册
    request.setAttribute("register_msg", "验证码错误");
    request.getRequestDispatcher("/register.jsp").forward(request, response);
    return;
}

// ... 验证码通过后，再执行后续注册逻辑 ...
```