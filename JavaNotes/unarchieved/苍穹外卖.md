

项目介绍：专门为餐饮企业（餐厅，饭店）定制的一款软件产品

功能架构：体现项目中的业务功能模块

管理端-员工管理/分类管理/菜品管理/套餐管理/订单管理/工作台/数据统计/来单提醒

用户端-微信登录/商品浏览/购物车/用户下单/微信支付/历史订单/地址管理/用户催单

技术选型：展示项目中使用到的技术框架和中间件

用户层：node.js/VUE.js/ElementUI/微信小程序/apache echarts（展示图标） 前端技术

网关层：Nginx

应用层：SpringBoot/SpringMVC/Spring Task/httpclient/springCache/JWT/阿里云oss/

Swagger（后端用于生成接口文档）/POI （操作excel）/WebSocket（协议）

数据层：MySQL/Redis/mybatis/pageHelper/spring data redis

工具：Git/maven/Junit/postman

## 开发环境搭建

整体结构：

前端（管理端web + 用户端 小程序）

后端：后端服务（Java）

### 前端环境搭建

前端工程基于nginx运行，双击nginx即可启动nginx服务，访问端口号为80

### 后端环境搭建

后端工程基于maven进行项目构建，并且进行分模块开发

Sky-take-our maven父工程，统一管理依赖版本，聚合其他子模块

Sky-common 子模块，存放公共类，例如工具类，常量类，异常类

sky-pojo 子模块，存放实体类，VO DTO等

（

DTO：数据传输对象，通常用于程序中各层之间传递数据，

VO：视图对象，为前端展示数据提供的对象，

POJO：普通java对象，只有属性和对应的getter/setter

）

Sky-server 子模块，后端服务，存放配置文件，Controller，Service，Mapper

#### 数据库环境搭建

通过数据库建表语句创建数据库表结构

员工表/分类表/菜品表/菜品口味表/套餐表/套餐菜品关系表/用户表/地址表/购物车表/订单表/订单明细表

#### Nginx代理

后端的初始工程中已经实现了登录功能，直接进行前后端联调测试即可

浏览器--Controller--service--mapper--数据库

前端发送的请求，如何请求到后端服务

前端请求的地址：localhost/api/employee/login

后端接口地址：localhost：8080/admin/employee/login

后端基于tomcat内嵌服务器，端口为8080 接口并不匹配

原因：nginx反向代理，将前端发送的动态请求有nginx转发到后端服务器

浏览器 -- localhost/api/employee/login -- nginx -- localhost：8080/admin/employee/login --Tomcat

Nginx反向代理的好处：

提高访问速度

进行负载均衡（把大量请求按照我们指定的方式均衡的分配给集群中的每台服务器）

保证后端服务安全

Nginx反向代理的配置方式

1.  Location/api/{
2.     Proxy_pass http://localhost:8080/admin/;
3.  }

Nginx负载均衡的配置方式

1.  upstream webservers{
2.   server 192.168.100.128:8080;
3.   server 192.168.100.129:8080;
4.  }

5.  server{
6.   listen 80;
7.   server_name localhost;

8.  location /api/ {
9.               proxy_pass   http://webservers/admin/;  _#负载均衡_
10.  }
11. }

底层基于反向代理实现

Nginx负载均衡策略：

轮询（默认方式）

Weight：权重方式，默认为1，权重越高，被分配的客户端请求就越多

Ip_hash：依据ip分配方式，这样每个访客可以固定访问一个后端服务

Least_conn：依据最少连接方式，把请求优先分配给连接数少的后端服务

Url_hash：依据url分配方式，这样相同的url会被分配到同一个后端服务

Fair：依据响应时间方式，响应时间短的服务将会被优先分配

### 完善登录功能

问题：员工表中的密码是明文存储，安全性太低

解决：将密码加密后存储，提高安全性，使用MD5加密算法对明文密码加密（不可逆）

修改数据库中明文密码，改为MD5加密后的密文

修改java代码，前端提交的密码进行MD5加密后在跟数据库中的密码比对

1.          _//密码比对_
2.          _//对于前端传来的明文密码进行md5加密，然后再进行比对_
3.          password = DigestUtils.md5DigestAsHex(password.getBytes());
4.          if (!password.equals(employee.getPassword())) {
5.              _//密码错误_
6.              throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
7.          }

8.          if (employee.getStatus() == StatusConstant.DISABLE) {
9.             _//账号被锁定_
10.             throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED);
11.         }

### 导入接口文档

#### 前后端分离开发流程

定制接口 - 前端开发/后端开发 - 联调（校验格式） - 提测（提测）

### Swagger

#### 介绍

使用Swagger你只需要按照它的规范去定义接口以及接口相关的信息，就可以做到生成接口文档，在线接口调试页面

Knifej是为java MVC框架集成Swagger生成Api文档的增强解决方案

#### 使用方式

导入knife4j的maven坐标

在配置类中加入knife4j相关配置

设置静态资源映射 否则接口文档页面无法访问

1.  _/\*\*_
2.       \* 通过knife4j生成接口文档
3.       \* @return
4.       \*/
5.      @Bean
6.      public Docket docket() {
7.          ApiInfo apiInfo = new ApiInfoBuilder()
8.                  .title("苍穹外卖项目接口文档")
9.                  .version("2.0")
10.                 .description("苍穹外卖项目接口文档")
11.                 .build();
12.         Docket docket = new Docket(DocumentationType.SWAGGER_2)
13.                 .apiInfo(apiInfo)
14.                 .select()
15.                 .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
16.                 .paths(PathSelectors.any())
17.                 .build();
18.         return docket;
19.     }

20.     _/\*\*_
21.      \* 设置静态资源映射
22.      \* @param registry
23.      \*/
24.     protected void addResourceHandlers(ResourceHandlerRegistry registry) {
25.         registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
26.         registry.addResourceHandler("/webjars/\*\*").addResourceLocations("classpath:/META-INF/resources/webjars/");
27.     }

生成如上

Postman/Yapi是设计阶段使用的工具，管理和维护接口

Swagger在开发阶段使用的框架，帮助后端开发人员做后端的接口测试

#### 常用注解

通过注解可以控制生成的接口文档，是接口文档拥有更好的可读性，常用注解如下

@Api 用在类上，例如Controller，表示到类的说明

@ApiModel 用在类上，例如entity DTO VO

@ApiModelProperty 用在属性上，描述属性信息

@ApiOperation 用在方法上 例如Controller的方法 说明方法的用途 作用

注解示例

1.  _/\*\*_
2.       \* 登录
3.       \*
4.       \* @param employeeLoginDTO
5.       \* @return
6.       \*/
7.      @PostMapping("/login")
8.      @ApiOperation("员工登录")
9.      public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {}

10.  @RestController
11.  @RequestMapping("/admin/employee")
12.  @Slf4j
13.  @Api(tags = "员工相关接口")

通过注解影响接口文档的生成

## 员工管理

新增员工/员工分页查询/启用禁用员工账号/编辑员工/导入分类模块功能代码

### 新增员工

#### 需求分析和设计

账号必须是唯一的/手机号校验，必须为11位手机号码（不能重复？）/

性别二选一/身份证是合法的18位身份证号码

密码默认为123456 后续可修改

使用Post请求提交json格式数据

项目约定：

管理端发出的请求，统一使用/admin作为前缀

用户端发出的请求，统一使用/user作为前缀

#### 代码开发

根据新增员工接口设计对应的DTO

如果直接使用实体类来接收？-可以 但当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据（精确封装）

EmployeeController

1.  _/\*\*_
2.       \* 新增员工
3.       \*
4.       \* @param employeeDTO
5.       \* @return
6.       \*/
7.      @PostMapping
8.      @ApiOperation("新增员工")
9.      public Result save(@RequestBody EmployeeDTO employeeDTO) {
10.         log.info("新增员工，员工数据：{}", employeeDTO);
11.         employeeService.save(employeeDTO);
12.         return Result.success();
13.     }

employeeService

employeeServiceImpl

1.      _/\*\*_
2.       \* 新增员工
3.       \*
4.       \* @param employeeDTO
5.       \*/
6.      public void save(EmployeeDTO employeeDTO) {
7.          Employee employee = new Employee();

8.          _// 对象属性拷贝(属性名要一致）_
9.         BeanUtils.copyProperties(employeeDTO, employee);

10.         _// 设置账号状态，默认正常状态_
11.         employee.setStatus(StatusConstant.ENABLE);

12.         _//设置密码，默认密码123456 （需要进行md5加密）_
13.         employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));

14.         _//设置当前记录的创建时间和修改时间_
15.         employee.setCreateTime(LocalDateTime.now());
16.         employee.setUpdateTime(LocalDateTime.now());

17.         _// 设置当前记录创建人id和修改人id_
18.         _// TODO: 改为当前登录用户的id_
19.         employee.setCreateUser(10L);
20.         employee.setUpdateUser(10L);

21.         employeeMapper.insert(employee);
22.     }

#### 功能测试

通过接口文档（swagger）测试

通过前后端联调测试（如果前端没有开发好 则无法联调）

开发阶段中，后端测试主要以接口文档测试为主

#### 代码完善

程序存在的问题：

##### 录入的用户名已存在

抛出异常后没有处理 只会报500错

1.      _/\*\*_
2.       \* 处理数据重复录入异常
3.       \* @param ex
4.       \* @return
5.       \*/
6.      @ExceptionHandler
7.      public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){
8.          _//Duplicate entry 'zhangsan' for key 'idx_username'_
9.          String message = ex.getMessage();
10.         if(message.contains("Duplicate entry")){
11.             String\[\] split = message.split(" ");
12.             String username = split\[2\];
13.             String msg = username + MessageConstant.ALREADY_EXISTS;
14.             return Result.error(msg);
15.         }else{
16.             return Result.error(MessageConstant.UNKNOWN_ERROR);
17.         }
18.     }

##### 新增员工时，创建人id和修改人id设置为了固定值

需要通过某种动态获取当前登录员工的id

认证流程：前端用户认证（提交用户名和密码）— 后端认证通过 生成JWT token返回给前端 — 前端在本地保存JWT Token — 后续请求后端接口 每次都在请求头中携带JWT token —被拦截器截获 拦截请求验证JWT token 通过则执行业务逻辑 反之则返回错误信息（401 未授权）

面临的问题 ： 解析出登录员工id后，如何传递给Service中的Save方法

解决：ThreadLocal 是 Thread的局部变量

为每个线程提供单独一份存储空间（因为每一个请求都是单独的线程） 具有线程隔离的效果 只有在线程内才能获取到对应的值 线程外则不能访问

1.  public class BaseContext {

2.      public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal<>();

3.      public static void setCurrentId(Long id) {
4.          threadLocal.set(id);
5.      }

6.      public static Long getCurrentId() {
7.         return threadLocal.get();
8.     }

9.     public static void removeCurrentId() {
10.         threadLocal.remove();
11.     }

12. }

BaseContext 是一个用于保存和管理当前线程用户 ID 的工具类。它通过 ThreadLocal&lt;Long&gt; 实现线程隔离，每个线程都可以独立存取自己的用户 ID，常用于登录态或用户上下文的保存。

setCurrentId(Long id)：设置当前线程的用户 ID。

getCurrentId()：获取当前线程的用户 ID。

removeCurrentId()：移除当前线程的用户 ID，防止内存泄漏。

拦截器

1.  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
2.          _//判断当前拦截到的是Controller的方法还是其他资源_
3.          if (!(handler instanceof HandlerMethod)) {
4.              _//当前拦截到的不是动态方法，直接放行_
5.              return true;
6.          }

7.          _//1、从请求头中获取令牌_
8.          String token = request.getHeader(jwtProperties.getAdminTokenName());

9.         _//2、校验令牌_
10.         try {
11.             log.info("jwt校验:{}", token);
12.             Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
13.             Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
14.             log.info("当前员工id：", empId);
15.             BaseContext.setCurrentId(empId);
16.             _//3、通过，放行_
17.             return true;
18.         } catch (Exception ex) {
19.             _//4、不通过，响应401状态码_
20.             response.setStatus(401);
21.             return false;
22.         }
23.     }

ServiceImpl

1.          _// 设置当前记录创建人id和修改人id_
2.          _// 改为当前登录用户的id_
3.          employee.setCreateUser(BaseContext.getCurrentId());
4.          employee.setUpdateUser(BaseContext.getCurrentId());

### 员工分页查询

#### 需求分析和设计

根据页码展示员工信息/每页展示10条数据/分页查询时可以根据需要 输入员工姓名进行查询

前端接口需要提交三个数据：页码page/每页展示的数据数pageSize/员工的姓名name

后端响应的：总的记录数total / 当前页需要展示的数据集合 records

#### 代码开发

根据分页查询接口设计对应的DTO 只需要封装name/page/pageSize

后面所有的分页查询，统一封装成PageResult对象

1.  @Data
2.  @AllArgsConstructor
3.  @NoArgsConstructor
4.  public class PageResult implements Serializable {
5.      private long total; _//总记录数_
6.      private List records; _//当前页数据集合_
7.  }

员工信息分页查询后端返回的对象类型为Result&lt;PageResult&gt;

1.      _/\*\*_
2.       \* 员工分页查询
3.       \*
4.       \* @param employeePageQueryDTO
5.       \* @return
6.       \*/
7.      @GetMapping("/page")
8.      @ApiOperation("员工分页查询")
9.      public Result&lt;PageResult&gt; page (EmployeePageQueryDTO employeePageQueryDTO) {
10.         log.info("员工分页查询，查询条件：{}", employeePageQueryDTO);
11.         PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
12.         return Result.success(pageResult);
13.     }

使用pageHelper辅助分页，底层基于拦截器实现

1.      @Override
2.      public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {
3.          _//select \* from employee limit 0,10_
4.          _//开始分页查询_
5.          PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());

6.          Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);

7.          long total = page.getTotal();
8.         List&lt;Employee&gt; records = page.getResult();

9.         return new PageResult(total, records);
10.     }

Mapper

1.      &lt;select id = "pageQuery"  resultType = "com.sky.entity.Employee"&gt;
2.          select \* from employee
3.          &lt;where&gt;
4.              &lt;if test="name != null and name != ''"&gt;
5.                  and name like concat('%', _#{name}, '%')_
6.              &lt;/if&gt;
7.          &lt;/where&gt;
8.          order by update_time desc
9.      &lt;/select&gt;

PageHelper会自动地拼接limit条件 接收体中封装了前端传来的分页DTO

#### 功能测试

可以通过接口文档进行测试，也可以进行前后端联调测试

问题：最后操作时间字段展示有问题

返回给前端的数据有问题 展示的形式不符合习惯

#### 代码完善

解决方式：

方式一：在属性上加入注解，对日期进行格式化

方式二：在WebMvcConfiguration中扩展springMVC的消息转换器，统一对日期类型进行格式化处理

1.      _/\*\*_
2.       \* 扩展springMVC的消息转换器
3.       \* @param converters
4.       \*/
5.      protected  void extendMessageConverters(List&lt;HttpMessageConverter<?&gt;> converters) {
6.          _// 创建一个消息转换器对象_
7.          MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
8.          _//需要为消息转换器设置一个对象转换器 对象转换器可以将Java对象序列化转为json_
9.          converter.setObjectMapper(new JacksonObjectMapper());
10.     }
11. _//将自己的消息转换器加入容器中_
12. converters.add(0,converter);

13.  public class JacksonObjectMapper extends ObjectMapper {

14.      public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
15.      _//public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";_
16.      public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
17.      public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

18.      public JacksonObjectMapper() {
19.          super();
20.         _//收到未知属性时不报异常_
21.         this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

22.         _//反序列化时，属性不存在的兼容处理_
23.         this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

24.         SimpleModule simpleModule = new SimpleModule()
25.                 .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
26.                 .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
27.                 .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
28.                 .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
29.                 .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
30.                 .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

31.         _//注册功能模块 例如，可以添加自定义序列化器和反序列化器_
32.         this.registerModule(simpleModule);
33.     }
34. }

### 启用/禁用员工账号

#### 需求分析和设计

业务规则：可以对状态为“启用”的员工账号进行“禁用操作”/可以对状态为“禁用”的员工账号进行“启用”操作/状态为“禁用”的员工账号不能登录系统

#### 代码开发

1.      _/\*\*_
2.       \* 启用禁用员工状态
3.       \* @param status
4.       \* @param id
5.       \*/
6.      @PostMapping("/status/{status}")
7.      @ApiOperation("启用禁用员工账号")
8.      public Result startOrStop(@PathVariable Integer status, Long id) {
9.          log.info("启用禁用员工账号，员工id：{}，状态：{}", id, status);
10.         employeeService.startOrStop(status, id);
11.         return Result.success();
12.     }

ServiceImpl

1.      _/\*\*_
2.       \* 启用禁用员工
3.       \*
4.       \* @param status
5.       \* @param id
6.       \*/
7.      @Override
8.      public void startOrStop(Integer status, Long id) {
9.          _//update employee set status = ? where id = ?_
10. _/\*        Employee employee = new Employee();_
11.         employee.setId(id);
12.         employee.setStatus(status);\*/

13.         Employee employee = Employee.builder()
14.                 .status(status)
15.                 .id(id)
16.                 .build();

17.         employeeMapper.update(employee);
18.     }

这里传 employee 对象是因为 employeeMapper.update(employee) 方法需要一个包含要更新字段的实体对象。这样可以灵活地只更新需要变更的字段（比如只改状态），而不是直接传 id 和 status，避免手动拼接 SQL，提高代码可维护性和扩展性。如果后续要更新更多字段，只需在对象里设置即可，无需修改方法签名。

EmployeeMapper

1.      &lt;update id="update" parameterType="Employee"&gt;
2.          update employee
3.          &lt;set&gt;
4.              &lt;if test="name != null"&gt;name = _#{name},&lt;/if&gt;_
5.              &lt;if test="username != null"&gt;username = _#{username},&lt;/if&gt;_
6.              &lt;if test="password != null"&gt;password = _#{password},&lt;/if&gt;_
7.              &lt;if test="phone != null"&gt;phone = _#{phone},&lt;/if&gt;_
8.              &lt;if test="sex != null"&gt;sex = _#{sex} &lt;/if&gt;_
9.              &lt;if test="idNumber != null"&gt;id_number = _#{idNumber},&lt;/if&gt;_
10.             &lt;if test="status != null"&gt;status = _#{status},&lt;/if&gt;_
11.             &lt;if test="updateTime != null"&gt;update_time = _#{updateTime},&lt;/if&gt;_
12.             &lt;if test="updateUser != null"&gt;update_user = _#{updateUser}&lt;/if&gt;_
13.         &lt;/set&gt;
14.         where id = _#{id}_
15.     &lt;/update&gt;

#### 功能测试

前后端联调

### 编辑员工

#### 需求分析和设计

编辑员工功能涉及两个接口：根据id查询员工信息/编辑员工信息

#### 代码开发

需要两种功能 一个是根据用户id查询员工信息 来完成点击修改按钮后的数据复现

还有一个则是调用mapper层的update完成根据id查询

1.      _/\*\*_
2.       \* 根据id查询员工信息
3.       \* @param id
4.       \* @return
5.       \*/
6.      @GetMapping("/{id}")
7.      @ApiOperation("根据id查询员工信息")
8.      public Result&lt;Employee&gt; getById(@PathVariable Long id) {
9.          log.info("根据id查询员工信息，员工id：{}", id);
10.         Employee employee = employeeService.getById(id);
11.         return Result.success(employee);
12.     }

13.     _/\*\*_
14.      \* 编辑员工信息
15.      \* @param employeeDTO
16.      \* @return
17.      \*/
18.     @PutMapping
19.     @ApiOperation("编辑员工信息")
20.     public Result update(@RequestBody EmployeeDTO employeeDTO) {
21.         log.info("编辑员工信息，员工信息：{}", employeeDTO);
22.         employeeService.update(employeeDTO);
23.         return Result.success();
24.     }

ServiceImpl

1.      _/\*\*_
2.       \* 根据id查询员工信息
3.       \*
4.       \* @param id
5.       \* @return
6.       \*/
7.      @Override
8.      public Employee getById(Long id) {
9.          Employee employee = employeeMapper.getById(id);
10.         employee.setPassword("\*\*\*\*");
11.         return employee;
12.     }

13.     _/\*\*_
14.      \* 编辑员工信息
15.      \*
16.      \* @param employeeDTO
17.      \*/
18.     @Override
19.     public void update(EmployeeDTO employeeDTO) {
20.         _//数据拷贝_
21.         Employee employee = new Employee();
22.         BeanUtils.copyProperties(employeeDTO, employee);

23.         employee.setUpdateTime(LocalDateTime.now());
24.         employee.setUpdateUser(BaseContext.getCurrentId());

25.         employeeMapper.update(employee);
26.     }

#### 功能测试

前后端联调与Swagger测试

## 分类管理

### 需求分析和设计

分类名称必须是唯一的

分类按照类型可以分为菜品分类和套餐分类

新添加的分类状态默认为“禁用”

### 接口设计

新增分类/分类分页查询/根据id删除分类/修改分类/启用禁用分类/根据类型查询分类

### 数据库开发

（category表）

Id 自增/name 唯一/type-菜品分类 套餐分类/sort-用于分类数据的排序/status/create_time/update_time/create_user/update_user

### 代码导入

. . .

### 功能测试

前后端联调

## 菜品管理

### 公共字段自动填充

偏向技术

业务表中有公共字段例如创建时间/创建人id/修改时间/修改人id，此前一直使用set来设置 会造成代码冗余

示例：

1.          _//设置当前记录的创建时间和修改时间_
2.          employee.setCreateTime(LocalDateTime.now());
3.          employee.setUpdateTime(LocalDateTime.now());

4.          _// 设置当前记录创建人id和修改人id_
5.          _// 改为当前登录用户的id_
6.          employee.setCreateUser(BaseContext.getCurrentId());
7.          employee.setUpdateUser(BaseContext.getCurrentId());

解决：

自定义注解AutoFill 用于表示需要进行公共字段自动填充的方法

1.  _/\*\*_
2.   \* 自动填充注解 用于表示某个方法需要进行功能字段自动填充处理
3.   \*/
4.  @Target(ElementType.METHOD)
5.  @Retention(RetentionPolicy.RUNTIME)
6.  public @interface AutoFill {
7.      _//数据库操作类型：UPDATE INSERT_
8.      OperationType value();
9.  }

自定义切面类AutoFillAspect，统一拦截加入AutoFill注解的方法，通过反射为公共字段赋值

1.  _/\*\*_
2.   \* 自动填充切面类 实现公共字段自动填充逻辑
3.   \*/
4.  @Aspect
5.  @Component
6.  @Slf4j
7.  public class AutoFillAspect {

8.      _/\*\*_
9.      \* 切入点
10.      \*/
11.     @Pointcut("execution(\* com.sky.mapper.\*.\*(..)) && @annotation(com.sky.annotation.AutoFill)")
12.     public void autoFillPointCut() {}

13.     @Before("autoFillPointCut()")
14.     public void autoFill(JoinPoint joinPoint) {
15.         log.info("开始进行公共字段自动填充...");

16.         _//获取当前被拦截的方法上的数据库操作类型（链式调用）_
17.         MethodSignature signature = (MethodSignature) joinPoint.getSignature();_//方法签名对象_
18.         AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);_//获得方法上得注解对象_
19.         OperationType operationType = autoFill.value();_//获得数据库操作类型对象_

20.         _//获取到当前被拦截的方法的参数--实体对象_
21.         Object\[\] args = joinPoint.getArgs();
22.         if (args == null || args.length == 0) {
23.             return;
24.         }

25.         Object entity = args\[0\];

26.         _//准备赋值的数据_
27.         LocalDateTime now = LocalDateTime.now();
28.         Long currentId = BaseContext.getCurrentId();

29.         _//根据不同的操作类型进行不同的自动填充_
30.         if (operationType == OperationType.INSERT) {
31.             _//为4个公共字段赋值_
32.             try {
33.                 Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
34.                 Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
35.                 Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
36.                 Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

37.                 _//通过反射为对象属性赋值_
38.                 setCreateTime.invoke(entity, now);
39.                 setUpdateTime.invoke(entity, now);
40.                 setCreateUser.invoke(entity, currentId);
41.                 setUpdateUser.invoke(entity, currentId);

42.             } catch (Exception e) {
43.                 e.printStackTrace();
44.             }
45.         } else if (operationType == OperationType.UPDATE) {
46.             _//为2个公共字段赋值_
47.             try {
48.                 Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
49.                 Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

50.                 setUpdateTime.invoke(entity, now);
51.                 setUpdateUser.invoke(entity, currentId);
52.             } catch (Exception e) {
53.                 e.printStackTrace();
54.             }
55.         }
56.     }
57. }

在Mapper的方法中加入AutoFill注解

1.      @AutoFill(value = OperationType.INSERT)
2.      @Insert("insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)" +
3.              " VALUES" +
4.              " (#{type}, #{name}, #{sort}, #{status}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser})")
5.      void insert(Category category);

### 新增菜品

#### 需求分析和设计

业务规则：菜品名称必须是唯一的/菜品必须属于某个分类下，不能单独存在/新增菜品时可以根据情况选择菜品的口味/每个菜品必须对应一个图片

接口设计：根据类型查询分类（已完成）/文件上传/新增菜品

数据库设计（dish菜品表和dish_flavour口味表）

#### 代码开发

##### 开发文件上传接口

浏览器-后端服务-阿里云OSS

CommonController

1.  _/\*\*_
2.   \* 通用接口
3.   \*/
4.  @RestController
5.  @RequestMapping("/admin/common")
6.  @Api(tags = "通用接口")
7.  @Slf4j
8.  public class CommonController {

9.     @Autowired
10.     private AliOssUtil aliOssUtil;

11.     @PostMapping("/upload")
12.     @ApiOperation("文件上传")
13.     public Result&lt;String&gt; upload(MultipartFile file) {
14.         log.info("文件上传：{}", file);

15.         try {
16.             _//原始文件名_
17.             String originalFilename = file.getOriginalFilename();
18.             _//截取原始文件名的后缀_
19.             String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
20.             _//新文件名称_
21.             String objectName = UUID.randomUUID().toString() + extension;

22.             _//文件的请求路径_
23.             String filePath = aliOssUtil.upload(file.getBytes(), objectName);
24.             return Result.success(filePath);
25.         } catch (IOException e) {
26.             log.error("文件上传失败", e);
27.         }

28.         return Result.error(MessageConstant.UPLOAD_FAILED);
29.     }

OssConfiguration

1.  _/\*\*_
2.   \* oss配置类 用于创建AliOssUtil对象
3.   \*/
4.  @Configuration
5.  @Slf4j
6.  public class OssConfiguration {

7.      @Bean
8.      @ConditionalOnMissingBean
9.     public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties) {
10.         log.info("开始创建AliOssUtil对象，参数：{}", aliOssProperties);
11.         return new AliOssUtil(aliOssProperties.getEndpoint(),
12.                 aliOssProperties.getAccessKeyId(),
13.                 aliOssProperties.getAccessKeySecret(),
14.                 aliOssProperties.getBucketName());
15.     }
16. }

配置到环境变量中 防止密钥泄露

1.    alioss:
2.      endpoint: ${sky.alioss.endpoint}
3.      access-key-id: ${sky.alioss.access-key-id}
4.      access-key-secret: ${sky.alioss.access-key-secret}
5.      bucket-name: ${sky.alioss.bucket-name}

采用松散绑定

##### 新增菜品接口

1.  @RestController
2.  @RequestMapping("/admin/dish")
3.  @Api(tags = "菜品管理")
4.  @Slf4j
5.  public class DishController {

6.      @Autowired
7.      private DishService dishService;

8.     _/\*\*_
9.      \* 新增菜品
10.      \* @param dishDTO
11.      \* @return
12.      \*/
13.     @PostMapping
14.     @ApiOperation("新增菜品")
15.     public Result save(@RequestBody DishDTO dishDTO) {
16.         log.info("新增菜品：{}", dishDTO);
17.         dishService.saveWithFlavor(dishDTO);
18.         return Result.success();
19.     }
20. }

新增菜品要求与口味一起保存

在实现类中将新增菜品分两张表保存 先插入dishMapper再插入dishFlavorMapper

涉及到两张表所以使用事务统一的管理

1.  @Service
2.  @Slf4j
3.  public class DishServiceImpl implements DishService {

4.      @Autowired
5.      private DishMapper dishMapper;

6.      @Autowired
7.      private DishFlavorMapper dishFlavorMapper;

8.     _/\*\*_
9.      \* 新增菜品，同时保存对应的口味数据
10.      \* @param dishDTO
11.      \*/
12.     @Override
13.     @Transactional
14.     public void saveWithFlavor(DishDTO dishDTO) {

15.         Dish dish = new Dish();
16.         BeanUtils.copyProperties(dishDTO,dish);

17.         _//向菜品表中插入1条数据_
18.         dishMapper.insert(dish);

19.         _//获取insert语句生成的主键值_
20.         Long dishId = dish.getId();

21.         _//向口味表插入n条数据_
22.         List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();

23.         if(flavors != null && flavors.size() > 0){
24.             flavors.forEach(flavor -> {
25.                 flavor.setDishId(dishId);
26.             });
27.             _//向口味表插入n条数据_
28.             dishFlavorMapper.insertBatch(flavors);
29.         }
30.     }
31. }

主键返回

DishMapper

1.      &lt;insert id="insert" useGeneratedKeys="true" keyProperty="id"&gt;
2.          INSERT INTO dish (name, category_id, price, image, description, create_time, update_time,create_user, update_user,  status)
3.          VALUES (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{createTime}, #{updateTime},#{createUser}, #{updateUser},#{status})
4.      &lt;/insert&gt;

DishFlavorMapper

1.      &lt;insert id="insertBatch"&gt;
2.          INSERT INTO dish_flavor (dish_id, name, value)
3.          VALUES
4.          &lt;foreach collection="flavors" item="df" separator=","&gt;
5.              (#{df.dishId}, _#{df.name}, #{df.value})_
6.          &lt;/foreach&gt;
7.      &lt;/insert&gt;

#### 功能测试

前后端联调

### 菜品分页查询

#### 需求分析和设计

业务规则：根据页码展示菜品信息

每页展示10条数据

分页查询时可以根据需要输入菜品名称，菜品分类，菜品状态进行查询

#### 代码开发

根据菜品分页查询接口定义设计对应的DTO 这是接受的数据类型

还需要设计一个dishVO 扩展了一个categoryName 回传给前端的数据

DishController

1.      _/\*\*_
2.       \* 菜品分页查询
3.       \* @param dishPageQueryDTO
4.       \* @return
5.       \*/
6.      @GetMapping("/page")
7.      @ApiOperation("菜品分页查询")
8.      public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO) {
9.          log.info("菜品分页查询：{}", dishPageQueryDTO);
10.         PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);
11.         return Result.success(pageResult);
12.     }

从前端获取一个DishPageQueryDTO 包含page/pageSize/name/categoryId/status

返回一个Result对象，内部封装pageResult

ServiceImpl

1.      public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) {

2.          PageHelper.startPage(dishPageQueryDTO.getPage(),dishPageQueryDTO.getPageSize());

3.          Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);

4.          return new PageResult(page.getTotal(),page.getResult());
5.      }

page泛型DishVO 内部包含

id/name/categoryId/price/description/status/updateTime/categoryName/flavor 表示返回给前端的数据

为什么用 DishVO：

DishVO 是“视图对象”，用于返回给前端的数据结构。它通常比实体类 Dish 包含更多展示信息，比如口味、分类名等，便于页面展示和数据封装。这样可以灵活控制返回内容，避免直接暴露数据库结构

dishMapper

通过组装查询来实现

1.      &lt;select id="pageQuery" resultType="com.sky.vo.DishVO"&gt;
2.          SELECT d.\* , c.name AS categoryName from dish d left outer join category c on d.category_id = c.id
3.          &lt;where&gt;
4.              &lt;if test="name != null"&gt;
5.                  and d.name like concat('%', _#{name}, '%')_
6.              &lt;/if&gt;
7.              &lt;if test="categoryId != null"&gt;
8.                  and d.category_id = _#{categoryId}_
9.              &lt;/if&gt;
10.             &lt;if test="status != null"&gt;
11.                 and d.status = _#{status}_
12.             &lt;/if&gt;
13.         &lt;/where&gt;
14.         order by d.create_time desc
15.     &lt;/select&gt;

resultType 标签用于指定 SQL 查询结果要映射成哪个 Java 类型。

在你的例子里，resultType="com.sky.vo.DishVO" 表示查询结果会自动封装到 DishVO 类的对象中，字段名要和 SQL 查询的列名对应。这样 MyBatis 会把每一行结果转成一个 DishVO 实例，方便后续业务处理和返回前端。

#### 功能测试

前后端联调/Swagger

### 删除菜品

#### 需求分析和设计

业务规则：

可以一次删除一个菜品，也可以批量删除菜品

起售中的菜品不能删除

被套餐关联的菜品不能删除

删除菜品后，关联的口味数据也需要删除

设计数据库：

Dish表/dish_flavor表/setmeal_dish表（套餐dish关系表）

#### 代码开发

DishController

1.      @DeleteMapping
2.      @ApiOperation("菜品批量删除")
3.      public Result delete(@RequestParam List&lt;Long&gt; ids){
4.          log.info("菜品批量删除：{}", ids);
5.          dishService.deleteBatch(ids);
6.          return Result.success();
7.      }

批量删除 传入字符串ids 请求参数1，2，3 菜品id 之间用逗号分隔

@RequestParam 用于接收前端请求 URL 中的参数，并自动绑定到方法参数上。

在这里，@RequestParam List&lt;Long&gt; ids 表示前端通过类似 /admin/dish?ids=1&ids=2 传递多个 ids，Spring 会自动把这些参数组装成一个 List&lt;Long&gt; 传给 delete 方法。

DishServiceImpl

1.      _/\*\*_
2.       \* 菜品批量删除
3.       \* @param ids
4.       \*/
5.      @Override
6.      @Transactional
7.      public void deleteBatch(List&lt;Long&gt; ids) {
8.          _//判断当前菜品是否能够删除---是否存在起售中的菜品_
9.          for (Long id : ids) {
10.             Dish dish = dishMapper.getById(id);
11.             if(dish.getStatus() == StatusConstant.ENABLE){
12.                 _//当前菜品处于起售中不能删除_
13.                 throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
14.             }
15.         }

16.         _//判断当前菜品是否能够删除---是否被套餐关联_
17.         List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);
18.         if(setmealIds != null && setmealIds.size() > 0){
19.             _//当前菜品被套餐关联，不能删除_
20.             throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
21.         }

22.         _//删除菜品表中的菜品数据_
23.         for (Long id : ids) {
24.             dishMapper.deleteById(id);
25.             _//删除菜品关联的口味数据_
26.             dishFlavorMapper.deleteByDishId(id);
27.         }
28.     }

删除操作 匹配dishId

DishFlavorMapper

1.      _/\*\*_
2.       \* 根据菜品id查删除对应的口味数据
3.       \* @param dishId
4.       \* @return
5.       \*/
6.      @Delete("delete from dish_flavor where dish_id = #{dishId}")
7.      void deleteByDishId(Long dishId);

DishMapper

1.      /\*\*
2.       \* 根据id查询菜品
3.       \*
4.       \* @param id
5.       \* @return
6.       \*/
7.      @Select("select \* from dish where id = #{id}")
8.      Dish getById(Long id);

9.     /\*\*
10.      \* 根据主键删除
11.      \* @param id
12.      \*/
13.     @Delete("delete from dish where id = #{id}")
14.     void deleteById(Long id);

根据id查询是为了获取对应id的状态 是否起售

查询确认可以删除后执行delete sql语句

#### 代码优化

此前使用for循环来对符合要求的逐个删除 以实现批量删除

现在写入sql用foreach遍历

1.      &lt;delete id="deleteByDishIds"&gt;
2.          delete from dish_flavor where dish_id in
3.          &lt;foreach collection="dishIds" item="dishId" open="(" separator="," close=")"&gt;
4.              _#{dishId}_
5.          &lt;/foreach&gt;
6.      &lt;/delete&gt;

7.      &lt;delete id="deleteByIds"&gt;
8.          delete from dish where id in
9.          &lt;foreach collection="ids" item="id" open="(" separator="," close=")"&gt;
10.              _#{id}_
11.          &lt;/foreach&gt;
12.      &lt;/delete&gt;

ServiceImpl

1.          //根据菜品id集合批量删除菜品数据
2.          //sql: delete from dish where id in (1,2,3)
3.          dishMapper.deleteByIds(ids);

4.          //根据菜品id集合批量删除关联的口味数据
5.          //sql: delete from dish_flavor where dish_id in (1,2,3)
6.          dishFlavorMapper.deleteByDishIds(ids);

### 修改菜品

#### 需求分析和设计

接口设计：根据id查询菜品（完成数据回显）

/根据类型查询分类（已实现）

/文件上传（已实现）

/修改菜品

#### 代码开发

##### 根据id查询菜品-数据回显

DishService

1.      _/\*\*_
2.       \* 根据id查询菜品及其对应的口味信息
3.       \* @param id
4.       \* @return
5.       \*/
6.      @GetMapping("/{id}")
7.      @ApiOperation("根据id查询菜品及其口味信息")
8.      public Result&lt;DishVO&gt; getById(@PathVariable Long id){
9.          log.info("根据id查询菜品及其口味信息：{}", id);
10.         DishVO dishVO = dishService.getByIdWithFlavor(id);
11.         return Result.success(dishVO);
12.     }

ServiceImpl

1.      _/\*\*_
2.       \* 根据id查询菜品及其对应的口味信息
3.       \* @param id
4.       \* @return
5.       \*/
6.      @Override
7.      public DishVO getByIdWithFlavor(Long id) {
8.          _//根据id查询菜品数据_
9.          Dish dish = dishMapper.getById(id);

10.         _//根据菜品id查询口味数据_
11.         List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

12.         _//将查询到的数据封装到VO_
13.         DishVO dishVO = new DishVO();
14.         BeanUtils.copyProperties(dish,dishVO);

15.         dishVO.setFlavors(dishFlavors);
16.         return dishVO;
17.     }

将查询到的数据封装到VO中返回到前端

1.      _/\*\*_
2.       \* 根据菜品id查询对应的口味数据
3.       \* @param dishId
4.       \* @return
5.       \*/
6.      @Select("select \* from dish_flavor where dish_id = #{dishId}")
7.      List&lt;DishFlavor&gt; getByDishId(Long dishId);

##### 实现修改菜品

同时修改对应的口味数据

1.      _/\*\*_
2.       \* 修改菜品，同时修改对应的口味数据
3.       \* @param dishDTO
4.       \*/
5.      @PutMapping
6.      @ApiOperation("修改菜品")
7.      public Result update(@RequestBody DishDTO dishDTO){
8.          dishService.updateWithFlavor(dishDTO);
9.          return Result.success();
10.     }

修改菜品 底层采用删除原有的口味数据 再插入新的口味数据

为了简化操作并提高代码复用 并且因为口味操作可能涉及的增删改复杂 所以这里先删除原有口味数据 再插入操作

1.      _/\*\*_
2.       \* 修改菜品，同时修改对应的口味数据
3.       \* @param dishDTO
4.       \*/
5.      @Override
6.      @Transactional
7.      public void updateWithFlavor(DishDTO dishDTO) {
8.          _//由于只修改基本数据 不修改口味数据_
9.          Dish dish = new Dish();
10.         BeanUtils.copyProperties(dishDTO,dish);

11.         _//修改菜品表基本数据_
12.         dishMapper.update(dish);

13.         _//删除原有的口味数据_
14.         dishFlavorMapper.deleteByDishId(dish.getId());

15.         _//插入新的口味数据_
16.         List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
17.         if(flavors != null && flavors.size() > 0){
18.             flavors.forEach(flavor -> {
19.                 flavor.setDishId(dish.getId());
20.             });
21.             _//向口味表插入n条数据_
22.             dishFlavorMapper.insertBatch(flavors);
23.         }
24.     }

#### 功能测试

前后端联调

## 店铺营业状态管理

### Redis入门

Redis是一个基于内存的key-value 基于内存存储，读写性能高，适合存储热点数据（热点商品 咨询 新闻）

### Redis常用命令在java中操作Redis店铺营业状态设置

#### 需求分析

接口设计：设置营业状态/管理端查询营业状态/用户端查询营业状态

本项目约定：

管理端发出的请求，统一使用/admin作为前缀

用户端发出的请求，统一使用/user作为前缀

营业状态数据存储方式：基于Redis的字符串进行存储 因为字符串总是0/1

SHOP_STATUS作为键

#### 代码开发

RedisConfiguration

1.  @Configuration
2.  @Slf4j
3.  public class RedisConfigurartion {

4.      @Bean
5.      public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
6.          log.info("开始创建redis模板对象...");
7.          RedisTemplate redisTemplate = new RedisTemplate();
8.          _//设置redis的连接工厂对象_
9.         redisTemplate.setConnectionFactory(redisConnectionFactory);
10.         _//设置key的序列化器_
11.         redisTemplate.setKeySerializer(new StringRedisSerializer());
12.         return redisTemplate;
13.     }
14. }

15.  @RestController("adminShopController")
16.  @RequestMapping("/admin/shop")
17.  @Api(tags = "店铺相关接口")
18.  @Slf4j
19.  public class ShopController {

20.      public static final String SHOP_STATUS_KEY = "SHOP_STATUS";

21.      @Autowired
22.     private RedisTemplate redisTemplate;

23.     _/\*\*_
24.      \* 店铺状态修改
25.      \* @param status
26.      \* @return
27.      \*/
28.     @PutMapping("/{status}")
29.     @ApiOperation("店铺状态修改")
30.     public Result setStatus(@PathVariable Integer status){
31.         log.info("店铺状态修改为，status：{}", status == 1 ? "营业中" : "打烊中");
32.         redisTemplate.opsForValue().set(SHOP_STATUS_KEY, status);
33.         return Result.success();
34.     }

35.     _/\*\*_
36.      \* 店铺状态查询
37.      \* @return
38.      \*/
39.     @GetMapping("/status")
40.     @ApiOperation("店铺状态查询")
41.     public Result&lt;Integer&gt; getStatus(){
42.         Integer status = (Integer) redisTemplate.opsForValue().get(SHOP_STATUS_KEY);
43.         log.info("店铺状态查询，status：{}", status == 1 ? "营业中" : "打烊中");
44.         return Result.success(status);
45.     }
46. }

#### 功能测试

Swagger