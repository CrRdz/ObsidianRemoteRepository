# 需求分析和设计

业务规则：
- 菜品名称必须是唯一的
- 菜品必须属于某个分类下 不能单独存在
- 新增菜品时可以根据情况选择菜品的口味
- 每个菜品必须对应一张图片
## 接口设计-根据类型查询分类（已完成）
- 基本信息
	- Path： /admin/category/list
	- Method:GET
- 请求参数
	Query

| 参数名称 | 是否必须 | 示例  | 备注                 |
| ---- | ---- | --- | ------------------ |
| type | 否    | 2   | 分类类型：1为菜品分类 2为套餐分类 |
- 返回数据

| 名称            | 类型      | 是否必须 | 默认值 | 备注  | 其他信息             |
| ------------- | ------- | ---- | --- | --- | ---------------- |
| code          | integer | 必须   |     |     | format:int32     |
| data          | object  | 必须   |     |     | item 类型：object   |
| ├─ id         | integer | 必须   |     |     | format:int64     |
| ├─ name       | string  | 必须   |     |     |                  |
| ├─ type       | string  | 必须   |     |     | format:int32     |
| ├─ sort       | string  | 必须   |     |     | format:int32     |
| ├─ createTime | string  | 必须   |     |     | format:date-time |
| ├─ updateTime | string  | 必须   |     |     | format:date-time |
| ├─ createUser | integer | 必须   |     |     | format:int64     |
| ├─ updateUser | integer | 必须   |     |     | format:int64     |
| msg           | string  | 必须   |     |     |                  |
	
## 接口设计-文件上传
- 基本信息
	- Path： /admin/category/list
	- Method:GET
- 请求参数
	Headers

| 参数名称         | 参数值                 | 是否必须 | 示例  | 备注  |
| ------------ | ------------------- | ---- | --- | --- |
| Content-type | multipart/form-data | 是    |     |     |
form-data 是浏览器文件上传的一种固定形式
- 返回数据

| 名称   | 类型      | 是否必须 | 备注     | 其他信息         |
| ---- | ------- | ---- | ------ | ------------ |
| code | integer | 必须   |        | format:int32 |
| data | string  | 必须   | 文件上传路径 |              |
| msg  | string  | 非必须  |        |              |
文件上传采用阿里云oss对象存储

## 接口设计-新增菜品
- 基本信息
	- Path:/admin/dish
	- Method:POST
- 请求参数
	Headers

| 参数名称         | 参数值              | 是否必须 | 示例  | 备注  |
| ------------ | ---------------- | ---- | --- | --- |
| Content-type | application/json | 是    |     |     |
	Body

| 名称          | 类型       | 是否必须 | 默认值 | 备注             | 其他信息           |
| ----------- | -------- | ---- | --- | -------------- | -------------- |
| categoryId  | integer  | 必须   |     | 分类id           | format:int64   |
| description | string   | 必须   |     | 菜品描述           |                |
| flavors     | object[] | 非必须  |     | 口味             | item 类型：object |
| ├─ dishId   | integer  | 非必须  |     | 菜品id           | format:int64   |
| ├─ id       | integer  | 必须   |     | 口味id           | format:int64   |
| ├─ name     | string   | 必须   |     | 口味名称           |                |
| ├─ value    | string   | 必须   |     | 口味值            |                |
| id          | integer  | 非必须  |     | 菜品id           | format:int64   |
| image       | integer  | 必须   |     | 菜品图片路径         |                |
| name        | string   | 必须   |     | 菜品名称           |                |
| price       | number   | 必须   |     | 菜品价格           |                |
| status      | integer  | 非必须  |     | 菜品状态：1为起售，0为停售 | format:int32   |
- 返回数据

| 名称   | 类型      | 是否必须 | 备注  | 其他信息         |
| ---- | ------- | ---- | --- | ------------ |
| code | integer | 必须   |     | format:int32 |
| data | object  | 非必须  |     |              |
| msg  | string  | 非必须  |     |              |
## 数据库设计

[[数据库设计文档#^0b4642|dish表]] 和 [[数据库设计文档#^a4b087| dish_flavor表]]
# 代码开发-文件上传接口

浏览器 $\rightarrow$ 后端服务$\rightarrow$ 阿里云OSS(这里暂时不做oss开发 存储到本地)

```java
@RestController  
@RequestMapping("/admin/common")  
@Api(tags = "通用接口")  
@Slf4j  
public class CommonController {  
  
    @PostMapping("/upload")  
    @ApiOperation("文件上传")  
    public Result<String> upload(MultipartFile file) {  
        log.info("文件上传：{}", file);  
  
        try {  
            // 1. 获取原始文件名 (例如: created_avatar.jpg)  
            String originalFilename = file.getOriginalFilename();  
  
            // 2. 获取文件后缀 (例如: .jpg)  
            // 健壮性处理：防止文件名为空  
            String extension = originalFilename != null ?  
                    originalFilename.substring(originalFilename.lastIndexOf(".")) : ".jpg";  
  
            // 3. 构造新文件名称，防止重名覆盖 (利用 UUID)            String newFileName = UUID.randomUUID().toString() + extension;  
  
            // 4. 指定本地保存的目录 (macOS 路径示例)  
            // 注意：你可以改为你想要的任何路径，比如 System.getProperty("user.dir") + "/upload/"            String baseDir = "/Users/crzhu/Downloads/sky-images/";  
            File dir = new File(baseDir);  
  
            // 如果目录不存在，则创建  
            if (!dir.exists()) {  
                dir.mkdirs();  
            }  
  
            // 5. 将接收到的文件存储到本地  
            // 拼接完整路径  
            File targetFile = new File(baseDir + newFileName);  
            file.transferTo(targetFile);  
  
            log.info("文件已保存至：{}", targetFile.getAbsolutePath());  
  
            // 6. 返回结果  
            // 注意：这里暂时返回的是本地绝对路径 前端未实现图片回显  
            // TODO 如果前端需要通过 http://localhost:8080/xx.jpg 访问图片，还需要在 Spring Boot 中配置静态资源映射 (ResourceHandler)。  
            return Result.success(targetFile.getAbsolutePath());  
  
        } catch (IOException e) {  
            log.error("文件上传失败", e);  
            return Result.error(MessageConstant.UPLOAD_FAILED);  
        }  
    }  
}
```
如果使用aliyun的话 还需开发工具类 这里简化流程暂时存储本地 但是会导致数据回显有问题

# 代码开发-新增菜品接口

## `DishController`

```java
/**  
 * 菜品管理  
 */  
@RestController  
@RequestMapping("/admin/dish")  
@Api(tags = "菜品相关接口")  
@Slf4j  
public class DishController {  
  
    @Autowired  
    private DishService dishService;  
  
    @PostMapping  
    @ApiOperation("新增菜品")  
    public Result save(@RequestBody DishDTO dishDTO) {  
        log.info("新增菜品：{}", dishDTO);  
        dishService.saveWithFlavor(dishDTO);  
        return Result.success();  
    }  
}
```

## `DishService`

```java
public interface DishService {  
  
    /**  
     * 新增菜品，同时保存对应的口味数据  
     * @param dishDTO  
     */  
    public void saveWithFlavor(DishDTO dishDTO);  
}
```

## `DishServiceImpl`

```java
@Service  
@Slf4j  
public class DishServiceImpl implements DishService {  
  
    @Autowired  
    private DishMapper dishMapper;  
  
    @Autowired  
    private DishFlavorMapper dishFlavorMapper;  
  
    /**  
     * 新增菜品，同时保存对应的口味数据  
     * @param dishDTO  
     */  
    @Override  
    @Transactional    
	public void saveWithFlavor(DishDTO dishDTO) {  
  
        Dish dish = new Dish();  
        BeanUtils.copyProperties(dishDTO, dish);  
  
        // 向菜品表插入1条数据  
        dishMapper.insert(dish);  
        Long dishId = dish.getId();  
  
        List<DishFlavor> flavors = dishDTO.getFlavors();  
        if (flavors != null && flavors.size() > 0) {  
            flavors.forEach(dishFlavor -> {  
                dishFlavor.setDishId(dishId);  
            });  
            // 向菜品口味表插入多条数据  
            dishFlavorMapper.insertBatch(flavors);  
        }  
    }
```

## `DishMapper`

```java
/**  
 * 插入菜品  
 * @param dish  
 */  
@AutoFill(value = OperationType.INSERT)  
void insert(Dish dish);
```

## `DishMapper.xml`

```xml
<mapper namespace="com.sky.mapper.DishMapper">  
  
    <insert id="insert" useGeneratedKeys="true" keyProperty="id">  
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user, update_user, status)  
            values         
            (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser}, #{status})    
    </insert>  
</mapper>
```

## `DishFlavorMapper`

```java
@Mapper  
public interface DishFlavorMapper {  
  
    /**  
     * 批量插入口味数据  
     * @param flavors  
     */  
    void insertBatch(List<DishFlavor> flavors);  
}
```

## `DishFlavorMapper.xml`

```java
<mapper namespace="com.sky.mapper.DishFlavorMapper">  
    <insert id="insertBatch">  
        insert into dish_flavor (dish_id, name, value)  
        values        
        <foreach collection="flavors" item="df" separator=",">  
            (#{df.dishId}, #{df.name}, #{df.value})  
        </foreach>  
    </insert>  
</mapper>
```
# 功能测试
前后端联调 + Swagger接口测试