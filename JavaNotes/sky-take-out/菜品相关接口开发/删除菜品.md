# 需求分析和设计

业务规则
- 可以一次删除一个菜品 也可以批量删除菜品
- 起售中的菜品不能删除
- 被套餐关联的菜品不能删除
- 删除菜品后关联的口味数据也需要被删除掉
## 接口设计
- 基本信息
	- Path:/admin/dish
	- Method:DELETE
- 请求参数
	Query

| 参数名称 | 是否必须 | 示例    | 备注           |
| ---- | ---- | ----- | ------------ |
| ids  | 是    | 1，2，3 | 菜品id 之间用逗号分隔 |
- 返回数据

| 名称   | 类型     | 是否必须 | 默认值 | 备注  | 其他信息 |
| ---- | ------ | ---- | --- | --- | ---- |
| code | number | 必须   |     |     |      |
| data | string | 非必须  |     |     |      |
| msg  | string | 非必须  |     |     |      |
## 数据库设计

操作涉及的表： [[数据库设计文档#^0b4642|dish表]] 和 [[数据库设计文档#^a4b087||dish_flavor表]]和 [[数据库设计文档#^3cc3c6|setmeal_dish表]]
# 代码开发
## `DishController`

```java
@DeleteMapping  
@ApiOperation("菜品批量删除")  
public Result delete(@RequestParam List<Long> ids) {  
    log.info("菜品批量删除：{}", ids);  
    dishService.deleteBatch(ids);  
    return Result.success();  
}
```

## `DishService`

```java
/**  
 * 菜品批量删除  
 * @param ids  
 */  
void deleteBatch(List<Long> ids);
```

## `DishServiceImpl`

```java
/**  
 * 菜品批量删除  
 * @param ids  
 */  
@Override  
@Transactional  
public void deleteBatch(List<Long> ids) {  
    // 判断当前菜品是否能够删除 --是否存在起售中的菜品  
    for (Long id : ids) {  
        Dish dish = dishMapper.getById(id);  
        if (dish.getStatus() == StatusConstant.ENABLE) {  
            // 当前菜品处于起售中 不能删除  
            throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);  
        }  
    }  
  
    // 判断当前菜品是否能够删除 --是否关联了套餐  
    List<Long> setmealIds = setmealDishMapper.getSetmealIdByDishIds(ids);  
    if (setmealIds != null && setmealIds.size() > 0) {  
        // 当前菜品关联了套餐 不能删除  
        throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);  
    }  
  
    // 删除菜品表中的菜品数据  
    for (Long id : ids) {  
        dishMapper.deletById(id);  
        // 删除菜品关联的口味数据  
        dishFlavorMapper.deleteByDishId(id);  
    }  
}
```

## `DishMapper`

```java
/**  
 * 根据id查询菜品  
 * @param id  
 * @return  
 */  
@Select("select * from dish where id = #{id}")  
Dish getById(Long id);  
  
/**  
 * 根据id删除菜品  
 * @param id  
 */  
@Delete("delete from dish where id = #{id}")  
void deletById(Long id);
```
## `SetmealDishMapper`

```java
@Mapper  
public interface SetmealDishMapper {  
  
    /**  
     * 根据菜品ids查询对应的套餐id集合  
     * @param dishIds  
     * @return  
     */  
    // select setmeal id from setmeal_dish where dish_id in (1,2,3);  
    List<Long> getSetmealIdByDishIds(List<Long> dishIds);  
}
```

## `SetmealDishMapper.xml`

```xml
<mapper namespace="com.sky.mapper.SetmealDishMapper">  
    <select id="getSetmealIdByDishIds" resultType="java.lang.Long">  
        SELECT DISTINCT setmeal_id  
        FROM setmeal_dish        
        WHERE dish_id IN        
        <foreach item="dishId" collection="dishIds" open="(" separator="," close=")">  
            #{dishId}  
        </foreach>  
    </select>  
</mapper>
```

## `DishFlavorMapper`

```java
/**  
 * 根据菜品id删除对应的口味数据  
 * @param dishId  
 */  
@Delete("delete from dish_flavor where dish_id = #{dishId}")  
void deleteByDishId(Long dishId);
```
# 功能测试
 
 前后端联调 + Swagger 测试
# 代码优化

之前使用for循环
```java
    // 删除菜品表中的菜品数据  
    for (Long id : ids) {  
        dishMapper.deletById(id);  
        // 删除菜品关联的口味数据  
        dishFlavorMapper.deleteByDishId(id);  
    }  
```
在高并发场景下 性能可能受限

## `DishController`

```java
// 根据菜品id集合批量删除菜品数据  
dishMapper.deleteByIds(ids);  
  
// 根据菜品id集合批量删除口味数据  
dishFlavorMapper.deleteByDishIds(ids);
```

## `DishFlavorMapper`

```java
/**  
 * 根据菜品ids批量删除对应的口味数据  
 * @param ids  
 */  
void deleteByDishIds(List<Long> ids);
```

## `DishFlavorMapper.xml`

```java
<delete id="deleteByDishIds">  
    delete from dish_flavor  
    where dish_id in    
    <foreach item="dishId" collection="dishIds" open="(" separator="," close=")">  
        #{dishId}  
    </foreach>  
</delete>
```