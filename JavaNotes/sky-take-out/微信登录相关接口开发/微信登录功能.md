# 需求分析和设计

业务规则
- 基于微信登录实现小程序（用户端）的登录功能
- 如果是新用户需要自动完成注册
## 接口设计
- 基本信息
	- Path:/user/user/login
	- Method:POST
- 请求参数
	Headers

| 参数名称         | 参数值              | 是否必须 | 示例  | 备注  |
| ------------ | ---------------- | ---- | --- | --- |
| Content-Type | application/json | 是    |     |     |
	Body
	
| 名称   | 类型     | 是否必须 | 默认值 | 备注      | 其他信息 |
| ---- | ------ | ---- | --- | ------- | ---- |
| code | string | 必须   |     | 微信用户授权码 |      |
- 返回数据

| 名称        | 类型      | 是否必须 | 默认值 | 备注       | 其他信息         |
| --------- | ------- | ---- | --- | -------- | ------------ |
| code      | integer | 必须   |     |          | format：int32 |
| data      | object  | 必须   |     |          |              |
| ├─ id     | integer | 必须   |     | 用户id     | format：int64 |
| ├─ openid | string  | 必须   |     | 微信openid |              |
| ├─ token  | string  | 必须   |     | jwt令牌    |              |
| msg       | string  | 非必须  |     |          |              |
# 数据库设计
[[数据库设计文档#^72b20a|user表]]
# 代码开发

## `UserLoginDTO`

```java
/**  
 * C端用户登录  
 */  
@Data  
public class UserLoginDTO implements Serializable {  
  
    private String code;  
  
}
```

## `UserLoginVO`

```java
@Data  
@Builder  
@NoArgsConstructor  
@AllArgsConstructor  
public class UserLoginVO implements Serializable {  
  
    private Long id;  
    private String openid;  
    private String token;  
  
}
```

## `UserController`

```java
@RestController  
@RequestMapping("/user/user")  
@Api(tags = "C端用户信息相关接口")  
@Slf4j  
public class UserController {  
  
    @Autowired  
    private UserService userService;  
  
    @Autowired  
    private JwtProperties jwtProperties;  
  
    @PostMapping("/login")  
    @ApiOperation("微信登录")  
    public Result<UserLoginVO> login(@RequestBody UserLoginDTO userLoginDTO) {  
        log.info("微信登录，userLoginDTO：{}", userLoginDTO.getCode());  
  
        // 调用service层微信登录方法  
        User user = userService.wxLogin(userLoginDTO);  
  
        // 为微信用户生成token，返回给前端  
        Map<String, Object> claims = new HashMap<>();  
        claims.put(JwtClaimsConstant.USER_ID, user.getId());  
        String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims);  
  
        UserLoginVO userLoginVO = UserLoginVO.builder()  
                .id(user.getId())  
                .openid(user.getOpenid())  
                .token(token)  
                .build();  
        return Result.success(userLoginVO);  
  
    }  
}
```
## `UserService`

```java
public interface UserService {  
  
    /**  
     * 微信登录  
     * @param userLoginDTO  
     * @return  
     */    
     User wxLogin(UserLoginDTO userLoginDTO);  
}
```

## `UserServiceImpl`

```java
@Service  
@Slf4j  
public class UserServiceImpl implements UserService {  
  
    // 微信服务接口地址  
    public static final String WX_LOGIN = "https://api.weixin.qq.com/sns/jscode2session";  
  
    @Autowired  
    private WeChatProperties weChatProperties;  
  
    @Autowired  
    private UserMapper userMapper;  
  
    public User wxLogin(UserLoginDTO userLoginDTO) {  
        log.info("微信用户登录:{}", userLoginDTO.getCode());  
  
        String openid = getOpenid(userLoginDTO.getCode());  
  
        // 判断openid是否为空  
        if(openid == null){  
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);  
        }  
  
        // 判断当前用户是否为新用户  
        User user = userMapper.getByOpenid(openid);  
  
        // 如果是新用户 自动完成注册  
        if(user == null){  
            user = User.builder()  
                    .openid(openid)  
                    .createTime(LocalDateTime.now())  
                    .build();  
            userMapper.insert(user);  
        }  
  
        // 返回这个用户对象  
        return user;  
    }  
  
    private String getOpenid(String code) {  
        // 调用微信接口服务 获得当前微信用户的openid  
        Map<String,String> map = new HashMap<>();  
        map.put("appid", weChatProperties.getAppid());  
        map.put("secret", weChatProperties.getSecret());  
        map.put("js_code", code);  
        map.put("grant_type", "authorization_code");  
        String json = HttpClientUtil.doGet(WX_LOGIN, map);  
  
        JSONObject jsonObject = JSONObject.parseObject(json);  
        String openid = jsonObject.getString("openid");  
  
        return openid;  
    }  
}
```

## `JwtTokenInterceptor`

```java
/**  
 * jwt令牌校验的拦截器  
 */  
@Component  
@Slf4j  
public class JwtTokenUserInterceptor implements HandlerInterceptor {  
  
    @Autowired  
    private JwtProperties jwtProperties;  
  
    /**  
     * 校验jwt  
     *     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //判断当前拦截到的是Controller的方法还是其他资源  
        if (!(handler instanceof HandlerMethod)) {  
            //当前拦截到的不是动态方法，直接放行  
            return true;  
        }  
  
        //1、从请求头中获取令牌  
        String token = request.getHeader(jwtProperties.getUserTokenName());  
  
        //2、校验令牌  
        try {  
            log.info("jwt校验:{}", token);  
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);  
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());  
            log.info("当前用户id：", userId);  
            BaseContext.setCurrentId(userId);  
  
            //3、通过，放行  
            return true;  
        } catch (Exception ex) {  
            //4、不通过，响应401状态码  
            response.setStatus(401);  
            return false;  
        }  
    }  
}
```

## `WebMVConfiguration`

```java
    registry.addInterceptor(jwtTokenUserInterceptor)  
            .addPathPatterns("/user/**")  
            .excludePathPatterns("/user/user/login")  
            .excludePathPatterns("/user/Shop/Staus");  
}
```

# 代码逻辑梳理

*generated by gemini*
## 1. 核心流程：登录与自动注册 (Login Flow)

这是用户打开小程序时发生的第一步操作。

**入口：`UserController.login`**

- **动作**：前端小程序调用 `wx.login()` 拿到一个临时的 `code`，然后把这个 `code` 发送给你的后端接口 `/user/user/login`。
    
- **目的**：Controller 接到 `code`，把它转交给 Service 层去处理核心业务。
    

**核心业务：`UserServiceImpl.wxLogin` (最关键的部分)**

这里做了三件大事：

1. **“换票” (Exchange Code for OpenID)**：
    
    - 调用 `getOpenid(code)` 方法。
        
    - **逻辑**：拿着前端传来的临时 `code`，加上你配置的 `appid` 和 `secret`，向微信服务器发起 HTTP 请求。
    
    - **结果**：微信服务器验证通过后，返回该用户唯一的身份标识 —— **OpenID**。
        
    - _注意：OpenID 是用户在你的小程序里的唯一身份证，永远不变。_
        
2. **“查户口” (Check User Existence)**：
    
    - `userMapper.getByOpenid(openid)`：去你自己的数据库里查，这个 OpenID 对应的用户是否存在。
        
3. **自动注册 (Auto Register)**：
    
    - **逻辑**：`if(user == null)`。如果数据库里没查到人，说明这是个新用户。
        
    - **操作**：立即创建一个新的 `User` 对象，填入 `openid` 和当前时间，然后 `insert` 到数据库。
        
    - _效果_：用户不需要手动点“注册”按钮，登录即注册，体验非常丝滑。
        

**收尾：颁发令牌 (Token Generation)**

- 回到 Controller，用户身份确认（或注册）完成后，后端生成一个 **JWT Token**。
    
- Token 的载荷（Payload）里放入了用户的 `userId`。
    
- 最后将 `id`, `openid`, `token` 打包返回给前端。前端拿到 Token 后会存起来，以后每次请求都带上。
    

---

## 2. 安全保障：请求拦截 (Security Flow)

这是用户登录**之后**，进行其他操作（比如下单、看个人中心）时的逻辑。

**守门员：`JwtTokenUserInterceptor`**

- **触发时机**：除了登录接口（被排除）外，其他访问 `/user/**` 的请求都会先经过这里。
    
- **检查门票**：
    
    1. 从 HTTP 请求头里取 `token`。
        
    2. `JwtUtil.parseJWT(...)`：验证 Token 是否伪造、是否过期。
        
- **解析身份**：
    
    - 如果验证通过，从 Token 里解析出 `userId`。
        
    - **关键点**：`BaseContext.setCurrentId(userId)`。
        
    - _解释_：这是利用 `ThreadLocal` 将用户 ID 存入当前线程。这样在后续的 Controller 或 Service 里，不需要一直传参数，随时调用 `BaseContext.getCurrentId()` 就能知道当前是谁在操作。
        
- **拦截**：如果 Token 验证失败（比如过期了），直接返回 401 状态码，前端就会跳回登录页。
    

---

## 3. 配置规则：`WebMVConfiguration`

这是“交通指挥中心”，负责把上面的“守门员”安排到指定的位置。

- `addPathPatterns("/user/**")`：规定所有用户端的接口都要检查 Token。
    
- `excludePathPatterns(...)`：
    
    - `/user/user/login`：**必须排除**。因为用户还没登录，肯定没有 Token，如果不排除就死循环了。
        
    - `/user/Shop/Staus`：看来店铺状态也是公开信息，不需要登录就能看。
        
## 逻辑亮点

使用了 **OpenID 作为唯一键**，这是开发微信小程序最标准的做法。同时配合 `ThreadLocal` (`BaseContext`) 存储用户状态，这在处理并发请求时是非常优雅的解耦方式。