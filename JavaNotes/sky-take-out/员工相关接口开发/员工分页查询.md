# 需求分析和设计

业务规则
- 根据页码展示员工星系	
- 每页展示10条数据
- 分页查询可以根据需要 输入姓名进行查询
## 接口设计
- 基本信息
	- Path: /admin/employee/page
	- Method: GET
- 请求参数
	Query

| 参数名称     | 是否必须 | 示例  | 备注    |
| -------- | ---- | --- | ----- |
| name     | 否    | 张三  | 员工姓名  |
| page     | 是    | 1   | 页码    |
| pageSize | 是    | 10  | 每页记录数 |
- 返回数据

| 名称              | 类型           | 是否必须 | 默认值 | 备注  | 其他信息           |
| --------------- | ------------ | ---- | --- | --- | -------------- |
| code            | number       | 必须   |     |     |                |
| msg             | null         | 非必须  |     |     |                |
| data            | object       | 必须   |     |     |                |
| ├─ total        | number       | 必须   |     |     |                |
| ├─ records      | object[]     | 必须   |     |     | item类型； object |
| │ ├─ id         | number       | 必须   |     |     |                |
| │ ├─ username   | string       | 必须   |     |     |                |
| │ ├─ name       | string       | 必须   |     |     |                |
| │ ├─ password   | string       | 必须   |     |     |                |
| │ ├─ phone      | string       | 必须   |     |     |                |
| │ ├─ sex        | string       | 必须   |     |     |                |
| │ ├─ idNumber   | string       | 必须   |     |     |                |
| │ ├─ Status     | number       | 必须   |     |     |                |
| │ ├─ createTime | string, null | 必须   |     |     |                |
| │ ├─ updateTime | string       | 必须   |     |     |                |
| │ ├─ createUser | number, null | 必须   |     |     |                |
| │ ├─ updateUser | number       | 必须   |     |     |                |
# 代码开发

根据分页查询接口设计的请求参数设计对应的DTO
```java
@Data  
public class EmployeePageQueryDTO implements Serializable {  
  
    //员工姓名  
    private String name;  
  
    //页码  
    private int page;  
  
    //每页显示记录数  
    private int pageSize;  
  
}
```

后面所有的分页查询 统一的封装成PageResult对象
```java
/**  
 * 封装分页查询结果  
 */  
@Data  
@AllArgsConstructor  
@NoArgsConstructor  
public class PageResult implements Serializable {  
  
    private long total; //总记录数  
  
    private List records; //当前页数据集合  
  
}
```

员工信息分页查询后端返回的对象类型为 `Result<PageResult>`

实用分页插件
```xml
<dependency>  
    <groupId>com.github.pagehelper</groupId>  
    <artifactId>pagehelper-spring-boot-starter</artifactId>  
    <version>${pagehelper}</version>  
</dependency>
```
底层基于MyBatis拦截器实现（动态拼SQL）

## `EmployeeController`

```java
/**  
 * 员工分页查询  
 * @param employeePageQueryDTO  
 * @return  
 */  
@GetMapping("/page")  
public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO) {  
    log.info("员工分页查询，参数为{}", employeePageQueryDTO);  
    PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);  
    return Result.success(pageResult);  
}
```

## `EmployeeService`

```java
/**  
 * 分页查询  
 * @param employeePageQueryDTO  
 * @return  
 */  
PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
```

## `EmployeeServiceImpl`

```java
/**  
 * 分页查询  
 * @param employeePageQueryDTO  
 * @return  
 */  
@Override  
public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {  
    // select * from employee limit 0,10  
    //开始分页查询  
    PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());
  
    Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);  
  
    long total = page.getTotal();  
    List<Employee> records = page.getResult();  
  
    return new PageResult(total,records);  
}
```
你只需要关注业务数据的筛选，完全不用写 `LIMIT` 或 `OFFSET`，也不用手动写 count 查询。
PageHelper 帮你做的事 (拦截与修改): 当代码运行到 employeeMapper.pageQuery 时，PageHelper 会作为 MyBatis的插件介入。它检测到之前调用过 startPage，于是会做两件事：
自动修改 SQL: 它会在你的 SQL 后面自动追加数据库对应的分页语句（例如 MySQL 的 LIMIT 0, 10）。
自动 Count: 它会基于你的 SQL 自动生成一条 `SELECT COUNT(*)`语句并执行，用来计算总记录数 total。

## `EmployeeMapper`

```java
/**  
 * 分页查询  
 *  
 * @param employeePageQueryDTO  
 * @return  
 */  
Page<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
```

## `EmployeeMapper.xml`

```xml
<mapper namespace="com.sky.mapper.EmployeeMapper">  
    <select id="pageQuery" resultType="com.sky.entity.Employee">  
        select * from employee  
        <where>  
            <if test = "name != null and name !=''">  
                and name like concat('%',#{name},'%')  
            </if>  
        </where>  
        order by create_time desc  
    </select>  
</mapper>
```

# 功能测试
 前后端联调 + Swagger 测试
# 代码完善
后端响应回前端的时间数据格式有问题 （修改时间）

## 解决方式
- 方式一： 在Employee 实体类属性上加入注解 对日期进行格式化
	```java
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")  
	private LocalDateTime createTime;  
  
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")  
	private LocalDateTime updateTime;
	```
- 方式二： 在`WebMvcConfiguration` 中扩展 Spring MVC的消息转换器 统一对日期类型进行格式化处理
	前置对象转换器
```java
/**  
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象  
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]  
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]  
 */
public class JacksonObjectMapper extends ObjectMapper {  
  
    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";  
    //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";  
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";  
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";  
  
    public JacksonObjectMapper() {  
        super();  
        //收到未知属性时不报异常  
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);  
  
        //反序列化时，属性不存在的兼容处理  
        this.getDeserializationConfig()
		        .withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);  
  
        SimpleModule simpleModule = new SimpleModule()  
                .addDeserializer(LocalDateTime.class, 
new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  
                .addDeserializer(LocalDate.class, 
new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))  
                .addDeserializer(LocalTime.class, 
new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))  
                .addSerializer(LocalDateTime.class, 
new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  
                .addSerializer(LocalDate.class, 
new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))  
                .addSerializer(LocalTime.class, 
new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));  
  
        //注册功能模块 例如，可以添加自定义序列化器和反序列化器  
        this.registerModule(simpleModule);  
    }  
}
```

WebMvcConfiguration
配置 扩展SpringMVC消息转换器
```java
/**  
 * 扩展Spring MVC消息转换器  
 * @param converters  
 */  
@Override  
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {  
    log.info("扩展消息转换器...");  
    // 创建一个消息转换器对象  
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();  
  
    // 需要为转换器设置一个对象转换器 对象转换器可以将Java对象转换为json格式  
    converter.setObjectMapper(new JacksonObjectMapper());  
  
    // 将上面的消息转换器对象追加到mvc框架的转换器集合中  
    converters.add(0, converter);  
  
}
```