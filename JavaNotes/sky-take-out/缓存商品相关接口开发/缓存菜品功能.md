# 问题说明

用户端小程序展示的菜品数据都是通过查询数据库获得 如果用户端访问量比较大 数据库访问压力随之增大
# 实现思路

通过Redis来缓存菜品数据 减少数据库查询操作
开始 $\rightarrow$ 后端服务 $\rightarrow$  缓存是否存在 $\xrightarrow{NO}$ 查询数据库 $\rightarrow$ 载入缓存
开始 $\rightarrow$ 后端服务 $\rightarrow$  缓存是否存在 $\xrightarrow{YES}$ 读取缓存

缓存逻辑分析：
- 每个分类下的菜品保存一份缓存数据

| key    | value       |
| ------ | ----------- |
| dish_1 | string(...) |
- 数据库中菜品有变更时清理缓存数据
	- 修改管理段接口的DishController的相关方法 加入清理缓存的逻辑 需要改造的方法：
		- 新增菜品
		- 修改菜品
		- 批量删除菜品
		- 起售/停售菜品
# 代码开发
## `DishController`

```Java
/**  
 * 根据分类id查询菜品  
 *  
 * @param categoryId  
 * @return  
 */@GetMapping("/list")  
@ApiOperation("根据分类id查询菜品")  
public Result<List<DishVO>> list(Long categoryId) {  
    // 构造redis中的key 规则：dish_分类id  
    String key = "dish_" + categoryId;  
  
    // 查询redis中是否存在菜品数据  
    List<DishVO> list = (List<DishVO>) redisTemplate.opsForValue().get(key);  
    if (list != null && list.size() == 0) {  
        // 如果存在 直接返回 无需查询数据库  
        return Result.success(list);  
    }  
  
    // 如果不存在 查询数据库 将查询到的数据存入redis  
    Dish dish = new Dish();  
    dish.setCategoryId(categoryId);  
    dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品  
  
    list = dishService.listWithFlavor(dish);  
    redisTemplate.opsForValue().set(key, list);  
  
    return Result.success(list);  
}
```
通过redis 实现将数据库中的数据存入redis中以便于快速查询

## `admin/DishController`

```java
/**  
 * 清理菜品缓存  
 * @param pattern  
 */  
private void cleanCache(String pattern) {  
    Set keys = redisTemplate.keys(pattern);  
    redisTemplate.delete(keys);  
}
```
## 功能测试

前后端联调
