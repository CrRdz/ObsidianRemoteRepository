# 需求分析和设计

对产品原型的分析：
- 账号必须是唯一的
- 手机号为合法的11位手机号码
- 身份证号为合法的18位身份证号码
- 密码在新增时默认为123456

## 接口设计
- 基本信息
	- Path: /admin/employee
	- Method: POST
> 注： /admin 用于区分资源请求源 如果管理端发出的请求 统一使用/admin作为前缀， 用户端发出的请求统一使用/user作为前缀
- 接口参数
	Headers

| 参数名称         | 参数值              | 是否必须 | 示例  | 备注  |
| ------------ | ---------------- | ---- | --- | --- |
| Content-Type | application/json | 是    |     |     |
	Body

| 名称       | 类型      | 是否必须 | 默认值 | 备注   | 其他信息         |
| -------- | ------- | ---- | --- | ---- | ------------ |
| id       | integer | 非必须  |     | 员工id | format：int64 |
| idNumber | string  | 必须   |     | 身份证  |              |
| name     | string  | 必须   |     | 姓名   |              |
| phone    | string  | 必须   |     | 手机号  |              |
| sex      | string  | 必须   |     | 性别   |              |
| username | string  | 必须   |     | 用户名  |              |
- 返回数据

| 名称   | 类型      | 是否必须 | 默认值 | 备注  | 其他信息         |
| ---- | ------- | ---- | --- | --- | ------------ |
| code | integer | 必须   |     |     | format：int32 |
| data | string  | 非必须  |     |     |              |
| msg  | string  | 非必须  |     |     |              |
## 数据库设计
[[数据库设计文档#^f155a5|employee表]]
# 代码开发

根据新增员工接口设计对应的DTO:

| 名称       | 类型      | 是否必须 | 默认值 | 备注   | 其他信息         |
| -------- | ------- | ---- | --- | ---- | ------------ |
| id       | integer | 非必须  |     | 员工id | format：int64 |
| idNumber | string  | 必须   |     | 身份证  |              |
| name     | string  | 必须   |     | 姓名   |              |
| phone    | string  | 必须   |     | 手机号  |              |
| sex      | string  | 必须   |     | 性别   |              |
| username | string  | 必须   |     | 用户名  |              |
当前端提交的数据和实体类中对应的属性差别比较大时 建议使用DTO来封装数据
```java
@Data  
public class EmployeeDTO implements Serializable {  
  
    private Long id;  
  
    private String username;  
  
    private String name;  
  
    private String phone;  
  
    private String sex;  
  
    private String idNumber;  
  
}
```

## `EmployeeController`

```java
/**  
 * 新增员工  
 * @param employeeDTO  
 * @return  
 */  
@ApiOperation("新增员工")
@PostMapping  
public Result save(@RequestBody EmployeeDTO employeeDTO) {  
    log.info("新增员工:{}",employeeDTO);  
    employeeService.save(employeeDTO);  
    return Result.success();  
}
```

## `EmployeeService`

```java
/**  
 * 新增员工  
 * @param employeeDTO  
 */  
void save(EmployeeDTO employeeDTO);
```

## `EmployeeServiceImpl`

```java
/**  
 * 新增员工  
 * @param employeeDTO  
 */  
public void save(EmployeeDTO employeeDTO) {  
    Employee employee = new Employee();  
  
    // 对象属性拷贝 （属性名一致就可以对拷）  
    BeanUtils.copyProperties(employeeDTO, employee);  
  
    // 设置账号的状态 默认正常状态 1表示正常 0 表示锁定  
    employee.setStatus(StatusConstant.ENABLE);  
  
    // 设置密码 默认密码123456  
    employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));  
  
    // 设置当前记录的创建时间和修改时间  
    employee.setCreateTime(LocalDateTime.now());  
    employee.setUpdateTime(LocalDateTime.now());  
  
    // 设置当前记录创建人id和修改人id  
    // TODO 后期需要改为当前登录用户的id  
    employee.setCreateUser(10L);  
    employee.setUpdateUser(10L);  
  
    employeeMapper.insert(employee);  
}
```

## `EmployeeMapper`

```java
/**  
 * 插入员工数据  
 * @param employee  
 */  
@Insert("insert into employee (name, username, password, phone, sex, id_number,create_time, update_time, create_user, update_user, status)" +  
        "values" +  
        "(#{name}, #{username}, #{password}, #{phone}, #{sex}, #{idNumber},#{createTime}, #{updateTime}, #{createUser}, #{updateUser},#{status})")  
void insert(Employee employee);
```

# 功能测试
由于开发阶段前段和后端是并行开发的 后端完成某个功能后 此时前段对应的功能可能还没有开发完成 导致无法进行前后端联调测试 所以在开发阶段 后端测试主要以接口文档测试为主
- Swagger测试
- 前后端联调测试

## 代码完善
程序存在的问题
- 录入的用户名已存在 抛出异常后没有处理
	- 通过全局异常管理器控制
```java
/**  
 *  处理SQL异常  
 * @param ex  
 * @return  
 */  
@ExceptionHandler  
public  Result exceptionHandler(SQLIntegrityConstraintViolationException ex){  
    //Duplicate entry 'zhangsan' for key 'employee.idx_username'  
    String message = ex.getMessage();  
    if (message.contains("Duplicate entry")){  
        String[] split = message.split(" ");  
        String username = split[2];  
        String msg = username + MessageConstant.ALREADY_EXISTS;  
        return Result.error(msg);  
    }else{  
        return Result.error(MessageConstant.UNKNOWN_ERROR);  
    }  
}
```
- 新增员工时 创建人id和修改人id设置了固定值
		后续请求中前端会携带JWT令牌 通过JWT令牌可以解析出当前登录员工id
	- ThreadLocal 并不是一个Thread 而是 Thread的局部变量 他为每个线程提供单独一份存储空间 具有线程隔离的效果 只有在线程内才能获取到对应的值 线程外则不能访问
	`EmployeeServiceImpl`
	```java
	// 设置当前记录创建人id和修改人id  
employee.setCreateUser(BaseContext.getCurrentId());  
employee.setUpdateUser(BaseContext.getCurrentId());
	```
	`JwtTokenAdminInterceptor`
		存入ThreadLocal
	```java
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
    //判断当前拦截到的是Controller的方法还是其他资源  
    if (!(handler instanceof HandlerMethod)) {  
        //当前拦截到的不是动态方法，直接放行  
        return true;  
    }  
  
    //1、从请求头中获取令牌  
    String token = request.getHeader(jwtProperties.getAdminTokenName());  
  
    //2、校验令牌  
    try {  
        log.info("jwt校验:{}", token);  
        Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);  
        Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());  
        log.info("当前员工id：", empId);  
        BaseContext.setCurrentId(empId);  
  
        //3、通过，放行  
        return true;  
    } catch (Exception ex) {  
        //4、不通过，响应401状态码  
        response.setStatus(401);  
        return false;  
    }  
}
	```
关键步骤
       ` BaseContext.setCurrentId(empId);`  